diff --git a/CMakeLists.txt b/CMakeLists.txt
new file mode 100644
index 0000000..3e6534b
--- /dev/null
+++ b/CMakeLists.txt
@@ -0,0 +1,123 @@
+project(libfftw)
+
+cmake_minimum_required(VERSION 2.6)
+
+include(${CMAKE_SOURCE_DIR}/CheckMingwVersion.cmake)
+
+option(DISABLE_FORTRAN "disable fortran wrappers" ON)
+option(FFTW_SINGLE "compile in single precision" OFF)
+option(FFTW_DOUBLE "compile in double precision" ON)
+option(FFTW_LDOUBLE "compile in long double precision" OFF)
+option(ENABLE_OPENMP "compile in openmp extensions" OFF)
+option(BUILD_ALL_STATIC "build each and every library as a small static library" OFF)
+option(BUILD_STATIC "build one static library" OFF)
+option(BUILD_BENCHMARKS "build benchmarks" ON)
+
+add_definitions(-DHAVE_CONFIG_H)
+if(MSVC)
+    add_definitions(-D_CRT_SECURE_NO_WARNINGS -wd4700)
+endif(MSVC)
+
+if(FFTW_SINGLE)
+    set(FFTW_DOUBLE OFF)
+    set(FFTW_LDOUBLE OFF)
+elseif(FFTW_DOUBLE)
+    set(FFTW_LDOUBLE OFF)
+endif(FFTW_SINGLE)
+
+if(MINGW32)
+    add_definitions(-march=pentium4)
+endif(MINGW32)
+
+if(ENABLE_OPENMP)
+    add_definitions(-openmp)
+endif(ENABLE_OPENMP)
+
+set(PACKAGE "\"fftw\"")
+set(VERSION "\"3.2.2\"")
+set(PACKAGE_VERSION "${VERSION}")
+set(FFTW_CC "\"${CMAKE_C_COMPILER}\"")
+set(CODELET_OPTIM "\"\"")
+
+set(fftw_SRCS)
+
+include(ConfigureChecks.cmake)
+
+macro(prepend_prefix outList)
+    FILE(RELATIVE_PATH prefix ${CMAKE_SOURCE_DIR} ${CMAKE_CURRENT_SOURCE_DIR})
+    foreach(element ${${outList}})
+        set(_outList ${_outList} ${prefix}/${element})
+    endforeach(element ${${outList}})
+    set(${outList} ${_outList})
+endmacro(prepend_prefix outList)
+
+include_directories(
+    ${CMAKE_CURRENT_SOURCE_DIR}
+    ${CMAKE_CURRENT_BINARY_DIR}
+    ${CMAKE_CURRENT_SOURCE_DIR}/kernel
+    ${CMAKE_CURRENT_SOURCE_DIR}/simd
+    ${CMAKE_CURRENT_SOURCE_DIR}/dft
+    ${CMAKE_CURRENT_SOURCE_DIR}/dft/scalar
+    ${CMAKE_CURRENT_SOURCE_DIR}/dft/scalar/codelets
+    ${CMAKE_CURRENT_BINARY_DIR}/dft/scalar/codelets
+    ${CMAKE_CURRENT_SOURCE_DIR}/dft/simd
+    ${CMAKE_CURRENT_SOURCE_DIR}/dft/simd/codelets
+    ${CMAKE_CURRENT_BINARY_DIR}/dft/simd/codelets
+    ${CMAKE_CURRENT_SOURCE_DIR}/rdft
+    ${CMAKE_CURRENT_SOURCE_DIR}/rdft/scalar
+    ${CMAKE_CURRENT_SOURCE_DIR}/rdft/scalar/r2cb
+    ${CMAKE_CURRENT_BINARY_DIR}/rdft/scalar/r2cb
+    ${CMAKE_CURRENT_SOURCE_DIR}/rdft/scalar/r2cf
+    ${CMAKE_CURRENT_BINARY_DIR}/rdft/scalar/r2cf
+    ${CMAKE_CURRENT_SOURCE_DIR}/rdft/scalar/r2r
+    ${CMAKE_CURRENT_BINARY_DIR}/rdft/scalar/r2r
+    ${CMAKE_CURRENT_SOURCE_DIR}/rdft/simd
+    ${CMAKE_CURRENT_SOURCE_DIR}/rdft/simd/codelets
+    ${CMAKE_CURRENT_BINARY_DIR}/rdft/simd/codelets
+    ${CMAKE_CURRENT_SOURCE_DIR}/reodft
+    ${CMAKE_CURRENT_SOURCE_DIR}/api
+    ${CMAKE_CURRENT_SOURCE_DIR}/threads
+    ${CMAKE_CURRENT_SOURCE_DIR}/cell
+    ${CMAKE_CURRENT_SOURCE_DIR}/libbench2
+    ${CMAKE_CURRENT_SOURCE_DIR}/tests
+    ${CMAKE_CURRENT_SOURCE_DIR}/tools
+)
+add_subdirectory(kernel)
+add_subdirectory(simd)
+add_subdirectory(dft)
+add_subdirectory(rdft)
+add_subdirectory(reodft)
+add_subdirectory(api)
+add_subdirectory(threads)
+
+if(NOT BUILD_ALL_STATIC)
+    if(NOT BUILD_STATIC)
+        set(_shared SHARED)
+        set(fftw_SRCS ${fftw_SRCS} fftw.def)
+    else(NOT BUILD_STATIC)
+        set(_shared STATIC)
+    endif(NOT BUILD_STATIC)
+
+    if(FFTW_SINGLE)
+        set(FFTW_OUTPUT_NAME fftw3f-3)
+    elseif(FFTW_DOUBLE)
+        set(FFTW_OUTPUT_NAME fftw3-3)
+    elseif(FFTW_LDOUBLE)
+        set(FFTW_OUTPUT_NAME fftw3l-3)
+    endif(FFTW_SINGLE)
+
+    add_library(fftw ${_shared} ${fftw_SRCS})
+    set_target_properties(fftw PROPERTIES DEFINE_SYMBOL DLL_EXPORT
+                                          OUTPUT_NAME ${FFTW_OUTPUT_NAME})
+    install(TARGETS fftw RUNTIME DESTINATION bin
+                         LIBRARY DESTINATION lib
+                         ARCHIVE DESTINATION lib)
+
+    install(FILES api/fftw3.h api/fftw3.f DESTINATION include)
+endif(NOT BUILD_ALL_STATIC)
+
+if(BUILD_BENCHMARKS)
+    add_subdirectory(libbench2)
+    add_subdirectory(tests)
+endif(BUILD_BENCHMARKS)
+#add_subdirectory(tools)
diff --git a/CheckMingwVersion.cmake b/CheckMingwVersion.cmake
new file mode 100644
index 0000000..8a2e805
--- /dev/null
+++ b/CheckMingwVersion.cmake
@@ -0,0 +1,26 @@
+#
+# check mingw compiler version
+# 
+# Copyright (c) 2010, Ralf Habacker
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+#
+if (NOT MINGW32 AND NOT MINGW64)
+    exec_program(
+        ${CMAKE_C_COMPILER}
+        ARGS ${CMAKE_C_COMPILER_ARG1} -dumpmachine
+        OUTPUT_VARIABLE _machine
+    )
+    if (_machine STREQUAL mingw32)
+        set (MINGW32 1)
+        message(STATUS "found mingw 32 bit compiler")
+    elseif (_machine STREQUAL i686-w64-mingw32)
+        set (MINGW32 1)
+        set (MINGW_W32 1)
+        message(STATUS "found mingw 64 bit compiler")
+    elseif (_machine STREQUAL x86_64-w64-mingw32)
+        set (MINGW64 1)
+        set (MINGW_W64 1)
+        message(STATUS "found mingw 64 bit compiler")
+    endif (_machine STREQUAL mingw32)
+endif (NOT MINGW32 AND NOT MINGW64)
diff --git a/ConfigureChecks.cmake b/ConfigureChecks.cmake
new file mode 100644
index 0000000..d04a045
--- /dev/null
+++ b/ConfigureChecks.cmake
@@ -0,0 +1,273 @@
+if(MSVC)
+    set(inline __inline)
+endif(MSVC)
+set(HAVE_THREADS 1)
+set(WITH_OUR_MALLOC16 1)
+set(STDC_HEADERS 1)
+set(HAVE_UINTPTR_T 1)
+set(HAVE_UINTPTR_T 1)
+set(HAVE_SIMD 1)
+set(HAVE_LONG_DOUBLE 1)
+set(HAVE_OPENMP ${ENABLE_OPENMP})
+
+if(FFTW_SINGLE)
+    set(HAVE_SSE 1)
+elseif(FFTW_DOUBLE)
+   set(HAVE_SSE2 1) # only works in double precision
+endif(FFTW_SINGLE)
+
+if(FFTW_SINGLE)
+    set(FFTW_SYMBOL_PREFIX "fftwf_")
+elseif(FFTW_DOUBLE)
+    set(FFTW_SYMBOL_PREFIX "fftw_")
+elseif(FFTW_LDOUBLE)
+    set(FFTW_SYMBOL_PREFIX "fftwl_")
+endif(FFTW_SINGLE)
+
+if(BUILD_BENCHMARKS)
+    set(BENCHFFT_SINGLE ${FFTW_SINGLE})
+    set(BENCHFFT_DOUBLE ${FFTW_DOUBLE})
+    set(BENCHFFT_LDOUBLE ${FFTW_LDOUBLE})
+endif(BUILD_BENCHMARKS)
+#/* extra CFLAGS for codelets */
+#cmakedefine CODELET_OPTIM @CODELET_OPTIM@
+
+include(CheckIncludeFiles)
+include(CheckSymbolExists)
+include(CheckTypeSize)
+
+check_include_files(alloca.h HAVE_ALLOCA_H)
+check_include_files(stdlib.h HAVE_STDLIB_H)
+check_include_files(stdint.h HAVE_STDINT_H)
+check_include_files(stddef.h HAVE_STDDEF_H)
+check_include_files(altivec.h HAVE_ALTIVEC_H)
+check_include_files(c_asm.h HAVE_C_ASM_H)
+check_include_files(dlfcn.h HAVE_DLFCN_H)
+check_include_files(intrinsics.h HAVE_INTRINSICS_H)
+check_include_files(inttypes.h HAVE_INTTYPES_H)
+check_include_files(libintl.h HAVE_LIBINTL_H)
+check_include_files(limits.h HAVE_LIMITS_H)
+check_include_files(mach/mach_time.h HAVE_MACH_MACH_TIME_H)
+check_include_files(malloc.h HAVE_MALLOC_H)
+check_include_files(memory.h HAVE_MEMORY_H)
+check_include_files(stddef.h HAVE_STDDEF_H)
+check_include_files(stdint.h HAVE_STDINT_H)
+check_include_files(stdlib.h HAVE_STDLIB_H)
+check_include_files(strings.h HAVE_STRINGS_H)
+check_include_files(string.h HAVE_STRING_H)
+check_include_files(sys/stat.h HAVE_SYS_STAT_H)
+check_include_files(sys/sysctl.h HAVE_SYS_SYSCTL_H)
+check_include_files(sys/time.h HAVE_SYS_TIME_H)
+check_include_files(sys/types.h HAVE_SYS_TYPES_H)
+check_include_files(unistd.h HAVE_UNISTD_H)
+check_include_files(xmmintrin.h HAVE_XMMINTRIN_H)
+
+check_type_size("double" SIZEOF_DOUBLE)
+check_type_size("float" SIZEOF_FLOAT)
+check_type_size("int" SIZEOF_INT)
+check_type_size("long" SIZEOF_LONG)
+check_type_size("long long" SIZEOF_LONG_LONG)
+check_type_size("ptrdiff_t" SIZEOF_PTRDIFF_T)
+check_type_size("size_t" SIZEOF_SIZE_T)
+check_type_size("unsigned int" SIZEOF_UNSIGNED_INT)
+check_type_size("unsigned long" SIZEOF_UNSIGNED_LONG)
+check_type_size("unsigned long long" SIZEOF_UNSIGNED_LONG_LONG)
+check_type_size("void*" SIZEOF_VOID_P)
+
+######################################################################################
+
+#/* Define to enable extra FFTW debugging code. */
+#cmakedefine FFTW_DEBUG
+
+#/* Define to enable alignment debugging hacks. */
+#cmakedefine FFTW_DEBUG_ALIGNMENT
+
+#/* Define to enable debugging malloc. */
+#cmakedefine FFTW_DEBUG_MALLOC
+
+
+#/* Define to 1 if using `alloca.c'. */
+#cmakedefine C_ALLOCA
+
+#/* Define to enable the use of alloca(). */
+#cmakedefine FFTW_ENABLE_ALLOCA
+
+#/* Define to 1 if you have `alloca', as a function or macro. */
+#cmakedefine HAVE_ALLOCA
+
+#/* Define to 1 if you have the `abort' function. */
+#cmakedefine HAVE_ABORT
+
+#/* Define to enable Altivec optimizations. */
+#cmakedefine HAVE_ALTIVEC
+
+#/* Define to 1 if you have the `BSDgettimeofday' function. */
+#cmakedefine HAVE_BSDGETTIMEOFDAY
+
+#/* Define to enable optimizations for the Cell Broadband Engine */
+#cmakedefine HAVE_CELL
+
+#/* Define to 1 if you have the `clock_gettime' function. */
+#cmakedefine HAVE_CLOCK_GETTIME
+
+#/* Define to 1 if you have the `cosl' function. */
+#cmakedefine HAVE_COSL
+
+#/* Define to 1 if you have the declaration of `cosl', and to 0 if you don't.
+#   */
+#cmakedefine HAVE_DECL_COSL
+
+#/* Define to 1 if you have the declaration of `drand48', and to 0 if you
+#   don't. */
+#cmakedefine HAVE_DECL_DRAND48
+
+#/* Define to 1 if you have the declaration of `memalign', and to 0 if you
+#   don't. */
+#cmakedefine HAVE_DECL_MEMALIGN
+
+#/* Define to 1 if you have the declaration of `posix_memalign', and to 0 if
+#   you don't. */
+#cmakedefine HAVE_DECL_POSIX_MEMALIGN
+
+#/* Define to 1 if you have the declaration of `sinl', and to 0 if you don't.
+#   */
+#cmakedefine HAVE_DECL_SINL
+
+#/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
+#cmakedefine HAVE_DOPRNT
+
+#/* Define to 1 if you have the `drand48' function. */
+#cmakedefine HAVE_DRAND48
+
+#/* Define if you have a machine with fused multiply-add */
+#cmakedefine HAVE_FMA
+
+#/* Define to 1 if you have the `gethrtime' function. */
+#cmakedefine HAVE_GETHRTIME
+
+#/* Define to 1 if you have the `gettimeofday' function. */
+#cmakedefine HAVE_GETTIMEOFDAY
+
+#/* Define to 1 if hrtime_t is defined in <sys/time.h> */
+#cmakedefine HAVE_HRTIME_T
+
+#/* Define if the isnan() function/macro is available. */
+#cmakedefine HAVE_ISNAN
+
+#/* Define to 1 if you have the `m' library (-lm). */
+#cmakedefine HAVE_LIBM
+
+#/* Define to 1 if you have the `spe' library (-lspe). */
+#cmakedefine HAVE_LIBSPE
+
+#/* Define to 1 if you have the `spe2' library (-lspe2). */
+#cmakedefine HAVE_LIBSPE2
+
+#/* Define to 1 if you have the `mach_absolute_time' function. */
+#cmakedefine HAVE_MACH_ABSOLUTE_TIME
+
+#/* Define to 1 if you have the `memalign' function. */
+#cmakedefine HAVE_MEMALIGN
+
+#/* Define to 1 if you have the `memset' function. */
+#cmakedefine HAVE_MEMSET
+
+#/* Define to enable MIPS paired-single optimizations. */
+#cmakedefine HAVE_MIPS_PS
+
+#/* Define to enable use of MIPS ZBus cycle-counter. */
+#cmakedefine HAVE_MIPS_ZBUS_TIMER
+
+#/* Define if you have the MPI library. */
+#cmakedefine HAVE_MPI
+
+#/* Define if we have and are using OpenMP multithreading directives */
+#cmakedefine USING_OPENMP_THREADS
+
+#/* Define to 1 if you have the `posix_memalign' function. */
+#cmakedefine HAVE_POSIX_MEMALIGN
+
+#/* Define if you have POSIX threads libraries and header files. */
+#cmakedefine HAVE_PTHREAD
+
+#/* Define to 1 if you have the `read_real_time' function. */
+#cmakedefine HAVE_READ_REAL_TIME
+
+#/* Define to 1 if you have the `sinl' function. */
+#cmakedefine HAVE_SINL
+
+#/* Define to 1 if you have the `snprintf' function. */
+#cmakedefine HAVE_SNPRINTF
+
+#/* Define to 1 if you have the `sqrt' function. */
+#cmakedefine HAVE_SQRT
+
+#/* Define to enable SSE optimizations. */
+#cmakedefine HAVE_SSE @HAVE_SSE@
+
+#/* Define to enable SSE2 optimizations. */
+#cmakedefine HAVE_SSE2 @HAVE_SSE2@
+
+#/* Define to 1 if you have the `sysctl' function. */
+#cmakedefine HAVE_SYSCTL
+
+#/* Define to 1 if you have the `tanl' function. */
+#cmakedefine HAVE_TANL
+
+#/* Define if we have a threads library. */
+#cmakedefine HAVE_THREADS
+
+#/* Define to 1 if you have the `time_base_to_time' function. */
+#cmakedefine HAVE_TIME_BASE_TO_TIME
+
+#/* Define to 1 if the system has the type `uintptr_t'. */
+#cmakedefine HAVE_UINTPTR_T
+
+#/* Define to 1 if you have the `vprintf' function. */
+#cmakedefine HAVE_VPRINTF
+
+#/* Define to 1 if you have the `_mm_free' function. */
+#cmakedefine HAVE__MM_FREE
+
+#/* Define to 1 if you have the `_mm_malloc' function. */
+#cmakedefine HAVE__MM_MALLOC
+
+#/* Define if you have the UNICOS _rtc() intrinsic. */
+#cmakedefine HAVE__RTC
+
+#/* Define to necessary symbol if this constant uses a non-standard name on
+#   your system. */
+#cmakedefine PTHREAD_CREATE_JOINABLE
+
+#/* If using the C implementation of alloca, define if you know the
+#   direction of stack growth for your system; otherwise it will be
+#   automatically deduced at runtime.
+#	STACK_DIRECTION > 0 => grows toward higher addresses
+#	STACK_DIRECTION < 0 => grows toward lower addresses
+#	STACK_DIRECTION = 0 => direction of growth unknown */
+#cmakedefine STACK_DIRECTION
+
+#/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#cmakedefine TIME_WITH_SYS_TIME
+
+##########################################################################
+# stuff I don't know what to do with:
+#/* Use low-precision timers, making planner very slow */
+#cmakedefine WITH_SLOW_TIMER
+#/* Define if we have and are using POSIX threads. */
+#cmakedefine USING_POSIX_THREADS
+
+# Fortran stuff: not implemented
+#cmakedefine DISABLE_FORTRAN
+#cmakedefine F77_DUMMY_MAIN
+#cmakedefine F77_FUNC
+#cmakedefine F77_FUNC_
+#cmakedefine F77_FUNC_EQUIV
+#cmakedefine FC_DUMMY_MAIN_EQ_F77
+#cmakedefine WINDOWS_F77_MANGLING
+#cmakedefine WITH_G77_WRAPPERS
+
+
+
+configure_file(config.h.cmake config.h)
+configure_file(fftw.def.cmake fftw.def)
diff --git a/api/CMakeLists.txt b/api/CMakeLists.txt
new file mode 100644
index 0000000..46aaf1f
--- /dev/null
+++ b/api/CMakeLists.txt
@@ -0,0 +1,41 @@
+set(api_SRCS apiplan.c configure.c execute-dft-c2r.c
+execute-dft-r2c.c execute-dft.c execute-r2r.c execute-split-dft-c2r.c
+execute-split-dft-r2c.c execute-split-dft.c execute.c
+export-wisdom-to-file.c export-wisdom-to-string.c export-wisdom.c
+f77api.c flops.c forget-wisdom.c import-system-wisdom.c
+import-wisdom-from-file.c import-wisdom-from-string.c import-wisdom.c
+malloc.c map-r2r-kind.c mapflags.c mkprinter-file.c mktensor-iodims.c
+mktensor-rowmajor.c plan-dft-1d.c plan-dft-2d.c plan-dft-3d.c
+plan-dft-c2r-1d.c plan-dft-c2r-2d.c plan-dft-c2r-3d.c plan-dft-c2r.c
+plan-dft-r2c-1d.c plan-dft-r2c-2d.c plan-dft-r2c-3d.c plan-dft-r2c.c
+plan-dft.c plan-guru-dft-c2r.c plan-guru-dft-r2c.c plan-guru-dft.c
+plan-guru-r2r.c plan-guru-split-dft-c2r.c plan-guru-split-dft-r2c.c
+plan-guru-split-dft.c plan-many-dft-c2r.c plan-many-dft-r2c.c
+plan-many-dft.c plan-many-r2r.c plan-r2r-1d.c plan-r2r-2d.c
+plan-r2r-3d.c plan-r2r.c print-plan.c rdft2-pad.c the-planner.c
+version.c plan-guru64-dft-c2r.c
+plan-guru64-dft-r2c.c plan-guru64-dft.c plan-guru64-r2r.c
+plan-guru64-split-dft-c2r.c plan-guru64-split-dft-r2c.c
+plan-guru64-split-dft.c mktensor-iodims64.c
+)
+
+if(BUILD_ALL_STATIC)
+    add_library(api STATIC ${api_SRCS})
+else(BUILD_ALL_STATIC)
+    prepend_prefix(api_SRCS)
+    set(fftw_SRCS ${fftw_SRCS} ${api_SRCS} PARENT_SCOPE)
+endif(BUILD_ALL_STATIC)
+
+
+#BUILT_SOURCES = fftw3.f
+
+#if MAINTAINER_MODE
+#
+# convert constants to F77 PARAMETER statements
+#fftw3.f: 
+#	rm -f $@
+#	perl -pe 's/([A-Z0-9_]+)=([0-9]+)/\n      INTEGER \1\n      PARAMETER (\1=\2)\n/g' $< |egrep 'PARAMETER|INTEGER' > $@
+#	perl -pe 's/#define +([A-Z0-9_]+) +\(([+-]?[0-9]+)U?\)/\n      INTEGER \1\n      PARAMETER (\1=\2)\n/g' $< |egrep 'PARAMETER|INTEGER' >> $@
+#	perl -pe 'if (/#define +([A-Z0-9_]+) +\(([0-9]+)U? *<< *([0-9]+)\)/) { print "\n      INTEGER $$1\n      PARAMETER ($$1=",$$2 << $$3,")\n"; }' $< |egrep 'PARAMETER|INTEGER' >> $@
+#
+#endif # MAINTAINER_MODE
diff --git a/config.h.cmake b/config.h.cmake
new file mode 100644
index 0000000..d8ef741
--- /dev/null
+++ b/config.h.cmake
@@ -0,0 +1,380 @@
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define to compile in long-double precision. */
+#cmakedefine BENCHFFT_LDOUBLE
+
+/* Define to compile in single precision. */
+#cmakedefine BENCHFFT_SINGLE
+
+/* extra CFLAGS for codelets */
+#cmakedefine CODELET_OPTIM @CODELET_OPTIM@
+
+/* Define to one of `_getb67', `GETB67', `getb67' for Cray-2 and Cray-YMP
+   systems. This function is required for `alloca.c' support on those systems.
+   */
+#cmakedefine CRAY_STACKSEG_END
+
+/* Define to 1 if using `alloca.c'. */
+#cmakedefine C_ALLOCA
+
+/* Define to disable Fortran wrappers. */
+#cmakedefine DISABLE_FORTRAN
+
+/* Define to dummy `main' function (if any) required to link to the Fortran
+   libraries. */
+#cmakedefine F77_DUMMY_MAIN
+
+/* Define to a macro mangling the given C identifier (in lower and upper
+   case), which must not contain underscores, for linking with Fortran. */
+#cmakedefine F77_FUNC
+
+/* As F77_FUNC, but for C identifiers containing underscores. */
+#cmakedefine F77_FUNC_
+
+/* Define if F77_FUNC and F77_FUNC_ are equivalent. */
+#cmakedefine F77_FUNC_EQUIV
+
+/* Define if F77 and FC dummy `main' functions are identical. */
+#cmakedefine FC_DUMMY_MAIN_EQ_F77
+
+/* C compiler name and flags */
+#cmakedefine FFTW_CC @FFTW_CC@
+
+/* Define to enable extra FFTW debugging code. */
+#cmakedefine FFTW_DEBUG
+
+/* Define to enable alignment debugging hacks. */
+#cmakedefine FFTW_DEBUG_ALIGNMENT
+
+/* Define to enable debugging malloc. */
+#cmakedefine FFTW_DEBUG_MALLOC
+
+/* Define to enable the use of alloca(). */
+#cmakedefine FFTW_ENABLE_ALLOCA
+
+/* Define to compile in long-double precision. */
+#cmakedefine FFTW_LDOUBLE
+
+/* Define to compile in single precision. */
+#cmakedefine FFTW_SINGLE
+
+/* Define to 1 if you have the `abort' function. */
+#cmakedefine HAVE_ABORT @HAVE_ABORT@
+
+/* Define to 1 if you have `alloca', as a function or macro. */
+#cmakedefine HAVE_ALLOCA @HAVE_ALLOCA@
+
+/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).
+   */
+#cmakedefine HAVE_ALLOCA_H @HAVE_ALLOCA_H@
+
+/* Define to enable Altivec optimizations. */
+#cmakedefine HAVE_ALTIVEC @HAVE_ALTIVEC@
+
+/* Define to 1 if you have the <altivec.h> header file. */
+#cmakedefine HAVE_ALTIVEC_H @HAVE_ALTIVEC_H@
+
+/* Define to 1 if you have the `BSDgettimeofday' function. */
+#cmakedefine HAVE_BSDGETTIMEOFDAY @HAVE_BSDGETTIMEOFDAY@
+
+/* Define to enable optimizations for the Cell Broadband Engine */
+#cmakedefine HAVE_CELL @HAVE_CELL@
+
+/* Define to 1 if you have the `clock_gettime' function. */
+#cmakedefine HAVE_CLOCK_GETTIME @HAVE_CLOCK_GETTIME@
+
+/* Define to 1 if you have the `cosl' function. */
+#cmakedefine HAVE_COSL @HAVE_COSL@
+
+/* Define to 1 if you have the <c_asm.h> header file. */
+#cmakedefine HAVE_C_ASM_H @HAVE_C_ASM_H@
+
+/* Define to 1 if you have the declaration of `cosl', and to 0 if you don't.
+   */
+#cmakedefine HAVE_DECL_COSL @HAVE_DECL_COSL@
+
+/* Define to 1 if you have the declaration of `drand48', and to 0 if you
+   don't. */
+#cmakedefine HAVE_DECL_DRAND48 @HAVE_DECL_DRAND48@
+
+/* Define to 1 if you have the declaration of `memalign', and to 0 if you
+   don't. */
+#cmakedefine HAVE_DECL_MEMALIGN @HAVE_DECL_MEMALIGN@
+
+/* Define to 1 if you have the declaration of `posix_memalign', and to 0 if
+   you don't. */
+#cmakedefine HAVE_DECL_POSIX_MEMALIGN @HAVE_DECL_POSIX_MEMALIGN@
+
+/* Define to 1 if you have the declaration of `sinl', and to 0 if you don't.
+   */
+#cmakedefine HAVE_DECL_SINL @HAVE_DECL_SINL@
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#cmakedefine HAVE_DLFCN_H @HAVE_DLFCN_H@
+
+/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
+#cmakedefine HAVE_DOPRNT @HAVE_DOPRNT@
+
+/* Define to 1 if you have the `drand48' function. */
+#cmakedefine HAVE_DRAND48 @HAVE_DRAND48@
+
+/* Define if you have a machine with fused multiply-add */
+#cmakedefine HAVE_FMA @HAVE_FMA@
+
+/* Define to 1 if you have the `gethrtime' function. */
+#cmakedefine HAVE_GETHRTIME @HAVE_GETHRTIME@
+
+/* Define to 1 if you have the `gettimeofday' function. */
+#cmakedefine HAVE_GETTIMEOFDAY @HAVE_GETTIMEOFDAY@
+
+/* Define to 1 if hrtime_t is defined in <sys/time.h> */
+#cmakedefine HAVE_HRTIME_T @HAVE_HRTIME_T@
+
+/* Define to 1 if you have the <intrinsics.h> header file. */
+#cmakedefine HAVE_INTRINSICS_H @HAVE_INTRINSICS_H@
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#cmakedefine HAVE_INTTYPES_H @HAVE_INTTYPES_H@
+
+/* Define if the isnan() function/macro is available. */
+#cmakedefine HAVE_ISNAN @HAVE_ISNAN@
+
+/* Define to 1 if you have the <libintl.h> header file. */
+#cmakedefine HAVE_LIBINTL_H @HAVE_LIBINTL_H@
+
+/* Define to 1 if you have the `m' library (-lm). */
+#cmakedefine HAVE_LIBM @HAVE_LIBM@
+
+/* Define to 1 if you have the `spe' library (-lspe). */
+#cmakedefine HAVE_LIBSPE @HAVE_LIBSPE@
+
+/* Define to 1 if you have the `spe2' library (-lspe2). */
+#cmakedefine HAVE_LIBSPE2 @HAVE_LIBSPE2@
+
+/* Define to 1 if you have the <limits.h> header file. */
+#cmakedefine HAVE_LIMITS_H @HAVE_LIMITS_H@
+
+/* Define to 1 if the compiler supports `long double' */
+#cmakedefine HAVE_LONG_DOUBLE @HAVE_LONG_DOUBLE@
+
+/* Define to 1 if you have the `mach_absolute_time' function. */
+#cmakedefine HAVE_MACH_ABSOLUTE_TIME @HAVE_MACH_ABSOLUTE_TIME@
+
+/* Define to 1 if you have the <mach/mach_time.h> header file. */
+#cmakedefine HAVE_MACH_MACH_TIME_H @HAVE_MACH_MACH_TIME_H@
+
+/* Define to 1 if you have the <malloc.h> header file. */
+#cmakedefine HAVE_MALLOC_H @HAVE_MALLOC_H@
+
+/* Define to 1 if you have the `memalign' function. */
+#cmakedefine HAVE_MEMALIGN @HAVE_MEMALIGN@
+
+/* Define to 1 if you have the <memory.h> header file. */
+#cmakedefine HAVE_MEMORY_H @HAVE_MEMORY_H@
+
+/* Define to 1 if you have the `memset' function. */
+#cmakedefine HAVE_MEMSET @HAVE_MEMSET@
+
+/* Define to enable MIPS paired-single optimizations. */
+#cmakedefine HAVE_MIPS_PS @HAVE_MIPS_PS@
+
+/* Define to enable use of MIPS ZBus cycle-counter. */
+#cmakedefine HAVE_MIPS_ZBUS_TIMER @HAVE_MIPS_ZBUS_TIMER@
+
+/* Define if you have the MPI library. */
+#cmakedefine HAVE_MPI @HAVE_MPI@
+
+/* Define to enable OpenMP */
+#cmakedefine HAVE_OPENMP @HAVE_OPENMP@
+
+/* Define to 1 if you have the `posix_memalign' function. */
+#cmakedefine HAVE_POSIX_MEMALIGN @HAVE_POSIX_MEMALIGN@
+
+/* Define if you have POSIX threads libraries and header files. */
+#cmakedefine HAVE_PTHREAD @HAVE_PTHREAD@
+
+/* Define to 1 if you have the `read_real_time' function. */
+#cmakedefine HAVE_READ_REAL_TIME @HAVE_READ_REAL_TIME@
+
+/* Define to 1 if you have the `sinl' function. */
+#cmakedefine HAVE_SINL @HAVE_SINL@
+
+/* Define to 1 if you have the `snprintf' function. */
+#cmakedefine HAVE_SNPRINTF @HAVE_SNPRINTF@
+
+/* Define to 1 if you have the `sqrt' function. */
+#cmakedefine HAVE_SQRT @HAVE_SQRT@
+
+/* Define to enable SSE optimizations. */
+#cmakedefine HAVE_SSE @HAVE_SSE@
+
+/* Define to enable SSE2 optimizations. */
+#cmakedefine HAVE_SSE2 @HAVE_SSE2@
+
+/* Define to 1 if you have the <stddef.h> header file. */
+#cmakedefine HAVE_STDDEF_H @HAVE_STDDEF_H@
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#cmakedefine HAVE_STDINT_H @HAVE_STDINT_H@
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#cmakedefine HAVE_STDLIB_H @HAVE_STDLIB_H@
+
+/* Define to 1 if you have the <strings.h> header file. */
+#cmakedefine HAVE_STRINGS_H @HAVE_STRINGS_H@
+
+/* Define to 1 if you have the <string.h> header file. */
+#cmakedefine HAVE_STRING_H @HAVE_STRING_H@
+
+/* Define to 1 if you have the `sysctl' function. */
+#cmakedefine HAVE_SYSCTL @HAVE_SYSCTL@
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#cmakedefine HAVE_SYS_STAT_H @HAVE_SYS_STAT_H@
+
+/* Define to 1 if you have the <sys/sysctl.h> header file. */
+#cmakedefine HAVE_SYS_SYSCTL_H @HAVE_SYS_SYSCTL_H@
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#cmakedefine HAVE_SYS_TIME_H @HAVE_SYS_TIME_H@
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#cmakedefine HAVE_SYS_TYPES_H @HAVE_SYS_TYPES_H@
+
+/* Define to 1 if you have the `tanl' function. */
+#cmakedefine HAVE_TANL @HAVE_TANL@
+
+/* Define if we have a threads library. */
+#cmakedefine HAVE_THREADS @HAVE_THREADS@
+
+/* Define to 1 if you have the `time_base_to_time' function. */
+#cmakedefine HAVE_TIME_BASE_TO_TIME @HAVE_TIME_BASE_TO_TIME@
+
+/* Define to 1 if the system has the type `uintptr_t'. */
+#cmakedefine HAVE_UINTPTR_T @HAVE_UINTPTR_T@
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#cmakedefine HAVE_UNISTD_H @HAVE_UNISTD_H@
+
+/* Define to 1 if you have the `vprintf' function. */
+#cmakedefine HAVE_VPRINTF @HAVE_VPRINTF@
+
+/* Define to 1 if you have the <xmmintrin.h> header file. */
+#cmakedefine HAVE_XMMINTRIN_H @HAVE_XMMINTRIN_H@
+
+/* Define to 1 if you have the `_mm_free' function. */
+#cmakedefine HAVE__MM_FREE @HAVE__MM_FREE@
+
+/* Define to 1 if you have the `_mm_malloc' function. */
+#cmakedefine HAVE__MM_MALLOC @HAVE__MM_MALLOC@
+
+/* Define if you have the UNICOS _rtc() intrinsic. */
+#cmakedefine HAVE__RTC @HAVE__RTC@
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#cmakedefine LT_OBJDIR
+
+/* Name of package */
+#cmakedefine PACKAGE @PACKAGE@
+
+/* Define to the address where bug reports for this package should be sent. */
+#cmakedefine PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#cmakedefine PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#cmakedefine PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#cmakedefine PACKAGE_TARNAME
+
+/* Define to the version of this package. */
+#cmakedefine PACKAGE_VERSION @PACKAGE_VERSION@
+
+/* Define to necessary symbol if this constant uses a non-standard name on
+   your system. */
+#cmakedefine PTHREAD_CREATE_JOINABLE
+
+/* The size of `double', as computed by sizeof. */
+#cmakedefine SIZEOF_DOUBLE @SIZEOF_DOUBLE@
+
+/* The size of `float', as computed by sizeof. */
+#cmakedefine SIZEOF_FLOAT @SIZEOF_FLOAT@
+
+/* The size of `int', as computed by sizeof. */
+#cmakedefine SIZEOF_INT @SIZEOF_INT@
+
+/* The size of `long', as computed by sizeof. */
+#cmakedefine SIZEOF_LONG @SIZEOF_LONG@
+
+/* The size of `long long', as computed by sizeof. */
+#cmakedefine SIZEOF_LONG_LONG @SIZEOF_LONG_LONG@
+
+/* The size of `ptrdiff_t', as computed by sizeof. */
+#cmakedefine SIZEOF_PTRDIFF_T @SIZEOF_PTRDIFF_T@
+
+/* The size of `size_t', as computed by sizeof. */
+#cmakedefine SIZEOF_SIZE_T @SIZEOF_SIZE_T@
+
+/* The size of `unsigned int', as computed by sizeof. */
+#cmakedefine SIZEOF_UNSIGNED_INT @SIZEOF_UNSIGNED_INT@
+
+/* The size of `unsigned long', as computed by sizeof. */
+#cmakedefine SIZEOF_UNSIGNED_LONG @SIZEOF_UNSIGNED_LONG@
+
+/* The size of `unsigned long long', as computed by sizeof. */
+#cmakedefine SIZEOF_UNSIGNED_LONG_LONG @SIZEOF_UNSIGNED_LONG_LONG@
+
+/* The size of `void *', as computed by sizeof. */
+#cmakedefine SIZEOF_VOID_P @SIZEOF_VOID_P@
+
+/* If using the C implementation of alloca, define if you know the
+   direction of stack growth for your system; otherwise it will be
+   automatically deduced at runtime.
+	STACK_DIRECTION > 0 => grows toward higher addresses
+	STACK_DIRECTION < 0 => grows toward lower addresses
+	STACK_DIRECTION = 0 => direction of growth unknown */
+#cmakedefine STACK_DIRECTION
+
+/* Define to 1 if you have the ANSI C header files. */
+#cmakedefine STDC_HEADERS
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#cmakedefine TIME_WITH_SYS_TIME
+
+/* Define if we have and are using OpenMP multithreading directives */
+#cmakedefine USING_OPENMP_THREADS
+
+/* Define if we have and are using POSIX threads. */
+#cmakedefine USING_POSIX_THREADS
+
+/* Version number of package */
+#cmakedefine VERSION @VERSION@
+
+/* Use common Windows Fortran mangling styles for the Fortran interfaces. */
+#cmakedefine WINDOWS_F77_MANGLING
+
+/* Include g77-compatible wrappers in addition to any other Fortran wrappers.
+   */
+#cmakedefine WITH_G77_WRAPPERS
+
+/* Use our own 16-byte aligned malloc routine; mainly helpful for Windows
+   systems lacking aligned allocation system-library routines. */
+#cmakedefine WITH_OUR_MALLOC16
+
+/* Use low-precision timers, making planner very slow */
+#cmakedefine WITH_SLOW_TIMER
+
+/* Define to empty if `const' does not conform to ANSI C. */
+#cmakedefine const
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+#cmakedefine inline @inline@
+#endif
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+#cmakedefine size_t
diff --git a/dft/CMakeLists.txt b/dft/CMakeLists.txt
new file mode 100644
index 0000000..24cc3b6
--- /dev/null
+++ b/dft/CMakeLists.txt
@@ -0,0 +1,19 @@
+#SUBDIRS = scalar simd
+add_subdirectory(scalar)
+add_subdirectory(simd)
+
+# pkgincludedir = $(includedir)/fftw3@PREC_SUFFIX@
+# pkginclude_HEADERS = codelet-dft.h dft.h
+
+set(dft_SRCS bluestein.c buffered.c conf.c ct.c dftw-direct.c
+dftw-directsq.c dftw-generic.c dftw-genericbuf.c direct.c generic.c
+indirect.c indirect-transpose.c kdft-dif.c kdft-difsq.c kdft-dit.c
+kdft.c nop.c plan.c problem.c rader.c rank-geq2.c solve.c vrank-geq1.c
+zero.c)
+
+if(BUILD_ALL_STATIC)
+    add_library(dft STATIC ${dft_SRCS})
+else(BUILD_ALL_STATIC)
+    prepend_prefix(dft_SRCS)
+    set(fftw_SRCS ${fftw_SRCS} ${dft_SRCS} ${_fftw_SRCS} PARENT_SCOPE)
+endif(BUILD_ALL_STATIC)
diff --git a/dft/scalar/CMakeLists.txt b/dft/scalar/CMakeLists.txt
new file mode 100644
index 0000000..2981db9
--- /dev/null
+++ b/dft/scalar/CMakeLists.txt
@@ -0,0 +1,10 @@
+add_subdirectory(codelets)
+
+set(dft_scalar_SRCS ${dft_scalar_SRCS} n.c t.c)
+
+if(BUILD_ALL_STATIC)
+    add_library(dft_scalar STATIC ${dft_scalar_SRCS})
+else(BUILD_ALL_STATIC)
+    prepend_prefix(dft_scalar_SRCS)
+    set(_fftw_SRCS ${_fftw_SRCS} ${dft_scalar_SRCS} ${__fftw_SRCS} PARENT_SCOPE)
+endif(BUILD_ALL_STATIC)
diff --git a/dft/scalar/codelets/CMakeLists.txt b/dft/scalar/codelets/CMakeLists.txt
new file mode 100644
index 0000000..174eced
--- /dev/null
+++ b/dft/scalar/codelets/CMakeLists.txt
@@ -0,0 +1,113 @@
+# This Makefile.am specifies a set of codelets, efficient transforms
+# of small sizes, that are used as building blocks (kernels) by FFTW
+# to build up large transforms, as well as the options for generating
+# and compiling them.
+
+# You can customize FFTW for special needs, e.g. to handle certain
+# sizes more efficiently, by adding new codelets to the lists of those
+# included by default.  If you change the list of codelets, any new
+# ones you added will be automatically generated when you run the
+# bootstrap script (see "Generating your own code" in the FFTW
+# manual).
+
+###########################################################################
+
+###########################################################################
+# n1_<n> is a hard-coded FFT of size <n> (base cases of FFT recursion)
+set(N1 n1_2.c n1_3.c n1_4.c n1_5.c n1_6.c n1_7.c n1_8.c n1_9.c n1_10.c
+n1_11.c n1_12.c n1_13.c n1_14.c n1_15.c n1_16.c n1_32.c n1_64.c
+n1_20.c n1_25.c # n1_30.c n1_40.c n1_50.c
+)
+
+###########################################################################
+# t1_<r> is a "twiddle" FFT of size <r>, implementing a radix-r DIT step
+set(T1 t1_2.c t1_3.c t1_4.c t1_5.c t1_6.c t1_7.c t1_8.c t1_9.c
+t1_10.c t1_12.c t1_15.c t1_16.c t1_32.c t1_64.c
+t1_20.c t1_25.c # t1_30.c t1_40.c t1_50.c
+)
+
+# t2_<r> is also a twiddle FFT, but instead of using a complete lookup table
+# of trig. functions, it partially generates the trig. values on the fly
+# (this is faster for large sizes).
+set(T2 t2_4.c t2_8.c t2_16.c t2_32.c t2_64.c
+     t2_5.c t2_10.c t2_20.c t2_25.c
+)
+
+###########################################################################
+# The F (DIF) codelets are used for a kind of in-place transform algorithm,
+# but the planner seems to never (or hardly ever) use them on the machines
+# we have access to, preferring the Q codelets and the use of buffers
+# for sub-transforms.  So, we comment them out, at least for now.
+
+# f1_<r> is a "twiddle" FFT of size <r>, implementing a radix-r DIF step
+#F1 = # f1_2.c f1_3.c f1_4.c f1_5.c f1_6.c f1_7.c f1_8.c f1_9.c f1_10.c f1_12.c f1_15.c f1_16.c f1_32.c f1_64.c
+
+# like f1, but partially generates its trig. table on the fly
+#F2 = # f2_4.c f2_8.c f2_16.c f2_32.c f2_64.c
+
+###########################################################################
+# q1_<r> is <r> twiddle FFTs of size <r> (DIF step), where the output is
+# transposed.  This is used for in-place transposes in sizes that are
+# divisible by <r>^2.  These codelets have size ~ <r>^2, so you should
+# probably not use <r> bigger than 8 or so.
+set(Q1 q1_2.c q1_4.c q1_8.c  q1_3.c q1_5.c q1_6.c)
+
+###########################################################################
+set(ALL_CODELETS ${N1} ${T1} ${T2} ${F1} ${F2} ${Q1})
+
+include(${CMAKE_SOURCE_DIR}/support/codelets.cmake)
+
+set(SOLVTAB_NAME "X(solvtab_dft_standard)")
+
+set(CODLIST ${CMAKE_CURRENT_BINARY_DIR}/codlist.c)
+set(CODELET_NAME codelet_)
+
+write_codelet_list(${CODLIST} ${CODELET_NAME} ${SOLVTAB_NAME} ${ALL_CODELETS})
+
+set(dft_scalar_codelets_SRCS ${ALL_CODELETS})
+
+if(BUILD_ALL_STATIC)
+    add_library(dft_scalar_codelets STATIC ${dft_scalar_codelets_SRCS})
+else(BUILD_ALL_STATIC)
+    prepend_prefix(dft_scalar_codelets_SRCS)
+    set(__fftw_SRCS ${__fftw_SRCS} ${dft_scalar_codelets_SRCS} ${CODLIST} PARENT_SCOPE)
+endif(BUILD_ALL_STATIC)
+
+# this is old source code which can be changed later
+# only delete codlist.c in maintainer-mode, since it is included in the dist
+# FIXME: is there a way to delete in 'make clean' only when builddir != srcdir?
+#maintainer-clean-local:
+#	rm -f $(CODLIST)
+
+#if MAINTAINER_MODE
+#FLAGS_N1=$(DFT_FLAGS_COMMON)
+#FLAGS_T1=$(DFT_FLAGS_COMMON)
+#FLAGS_T2=$(DFT_FLAGS_COMMON) -twiddle-log3 -precompute-twiddles
+#FLAGS_F1=$(DFT_FLAGS_COMMON)
+#FLAGS_F2=$(DFT_FLAGS_COMMON) -twiddle-log3  -precompute-twiddles
+#FLAGS_Q1=$(DFT_FLAGS_COMMON) -reload-twiddle
+#FLAGS_Q2=$(DFT_FLAGS_COMMON) -twiddle-log3  -precompute-twiddles
+#
+#n1_%.c:  $(CODELET_DEPS) $(GEN_NOTW)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_NOTW) $(FLAGS_N1) -n $* -name n1_$* -include "n.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#t1_%.c:  $(CODELET_DEPS) $(GEN_TWIDDLE)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_TWIDDLE) $(FLAGS_T1) -n $* -name t1_$* -include "t.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#t2_%.c:  $(CODELET_DEPS) $(GEN_TWIDDLE)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_TWIDDLE) $(FLAGS_T2) -n $* -name t2_$* -include "t.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#f1_%.c:  $(CODELET_DEPS) $(GEN_TWIDDLE)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_TWIDDLE) $(FLAGS_F1) -dif -n $* -name f1_$* -include "f.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#f2_%.c:  $(CODELET_DEPS) $(GEN_TWIDDLE)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_TWIDDLE) $(FLAGS_F2) -dif -n $* -name f2_$* -include "f.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#q1_%.c:  $(CODELET_DEPS) $(GEN_TWIDSQ)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_TWIDSQ) $(FLAGS_Q1) -dif -n $* -name q1_$* -include "q.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#q2_%.c:  $(CODELET_DEPS) $(GEN_TWIDSQ)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_TWIDSQ) $(FLAGS_Q2) -dif -n $* -name q2_$* -include "q.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#endif # MAINTAINER_MODE
+
diff --git a/dft/simd/CMakeLists.txt b/dft/simd/CMakeLists.txt
new file mode 100644
index 0000000..a36a198
--- /dev/null
+++ b/dft/simd/CMakeLists.txt
@@ -0,0 +1,10 @@
+add_subdirectory(codelets)
+
+set(dft_simd_SRCS n1b.c n1f.c n2b.c n2f.c n2s.c q1b.c q1f.c t.c ts.c)
+
+if(BUILD_ALL_STATIC)
+    add_library(dft_simd STATIC ${dft_simd_SRCS})
+else(BUILD_ALL_STATIC)
+    prepend_prefix(dft_simd_SRCS)
+    set(_fftw_SRCS ${_fftw_SRCS} ${dft_simd_SRCS} ${__fftw_SRCS} PARENT_SCOPE)
+endif(BUILD_ALL_STATIC)
diff --git a/dft/simd/codelets/CMakeLists.txt b/dft/simd/codelets/CMakeLists.txt
new file mode 100644
index 0000000..74766d2
--- /dev/null
+++ b/dft/simd/codelets/CMakeLists.txt
@@ -0,0 +1,189 @@
+# This Makefile.am specifies a set of codelets, efficient transforms
+# of small sizes, that are used as building blocks (kernels) by FFTW
+# to build up large transforms, as well as the options for generating
+# and compiling them.
+
+# You can customize FFTW for special needs, e.g. to handle certain
+# sizes more efficiently, by adding new codelets to the lists of those
+# included by default.  If you change the list of codelets, any new
+# ones you added will be automatically generated when you run the
+# bootstrap script (see "Generating your own code" in the FFTW
+# manual).
+
+###########################################################################
+#AM_CPPFLAGS = -I$(top_srcdir)/kernel -I$(top_srcdir)/dft	\
+#-I$(top_srcdir)/dft/simd -I$(top_srcdir)/simd
+#AM_CFLAGS = $(SIMD_CFLAGS)
+#noinst_LTLIBRARIES = libdft_simd_codelets.la
+
+###########################################################################
+# n1fv_<n> is a hard-coded FFTW_FORWARD FFT of size <n>, using SIMD
+set(N1F n1fv_2.c n1fv_3.c n1fv_4.c n1fv_5.c n1fv_6.c n1fv_7.c n1fv_8.c
+n1fv_9.c n1fv_10.c n1fv_11.c n1fv_12.c n1fv_13.c n1fv_14.c n1fv_15.c
+n1fv_16.c n1fv_32.c n1fv_64.c n1fv_128.c
+n1fv_20.c n1fv_25.c # n1fv_30.c n1fv_40.c n1fv_50.c
+)
+
+# as above, with restricted input vector stride
+set(N2F n2fv_2.c n2fv_4.c n2fv_6.c n2fv_8.c n2fv_10.c n2fv_12.c
+n2fv_14.c n2fv_16.c n2fv_32.c n2fv_64.c
+n2fv_20.c # n2fv_30.c n2fv_40.c n2fv_50.c
+)
+
+# as above, but FFTW_BACKWARD
+set(N1B n1bv_2.c n1bv_3.c n1bv_4.c n1bv_5.c n1bv_6.c n1bv_7.c n1bv_8.c
+n1bv_9.c n1bv_10.c n1bv_11.c n1bv_12.c n1bv_13.c n1bv_14.c n1bv_15.c
+n1bv_16.c n1bv_32.c n1bv_64.c n1bv_128.c
+n1bv_20.c n1bv_25.c # n1bv_30.c n1bv_40.c n1bv_50.c
+)
+
+set(N2B n2bv_2.c n2bv_4.c n2bv_6.c n2bv_8.c n2bv_10.c n2bv_12.c
+n2bv_14.c n2bv_16.c n2bv_32.c n2bv_64.c
+n2bv_20.c # n2bv_30.c n2bv_40.c n2bv_50.c
+)
+
+# split-complex codelets 
+set(N2S n2sv_4.c n2sv_8.c n2sv_16.c n2sv_32.c n2sv_64.c
+)
+
+###########################################################################
+# t1fv_<r> is a "twiddle" FFT of size <r>, implementing a radix-r DIT step
+# for an FFTW_FORWARD transform, using SIMD
+set(T1F t1fv_2.c t1fv_3.c t1fv_4.c t1fv_5.c t1fv_6.c t1fv_7.c t1fv_8.c
+t1fv_9.c t1fv_10.c t1fv_12.c t1fv_15.c t1fv_16.c t1fv_32.c t1fv_64.c
+t1fv_20.c t1fv_25.c # t1fv_30.c t1fv_40.c t1fv_50.c
+)
+
+# same as t1fv_*, but with different twiddle storage scheme
+set(T2F t2fv_2.c t2fv_4.c t2fv_8.c t2fv_16.c t2fv_32.c t2fv_64.c
+t2fv_5.c t2fv_10.c t2fv_20.c t2fv_25.c
+)
+set(T3F t3fv_4.c t3fv_8.c t3fv_16.c t3fv_32.c
+t3fv_5.c t3fv_10.c t3fv_20.c t3fv_25.c
+)
+set(T1FU t1fuv_2.c t1fuv_3.c t1fuv_4.c t1fuv_5.c t1fuv_6.c t1fuv_7.c
+t1fuv_8.c t1fuv_9.c t1fuv_10.c
+)
+
+# as above, but FFTW_BACKWARD
+set(T1B t1bv_2.c t1bv_3.c t1bv_4.c t1bv_5.c t1bv_6.c t1bv_7.c t1bv_8.c
+t1bv_9.c t1bv_10.c t1bv_12.c t1bv_15.c t1bv_16.c t1bv_32.c t1bv_64.c
+t1bv_20.c t1bv_25.c # t1bv_30.c t1bv_40.c t1bv_50.c
+)
+
+# same as t1bv_*, but with different twiddle storage scheme
+set(T2B t2bv_2.c t2bv_4.c t2bv_8.c t2bv_16.c t2bv_32.c t2bv_64.c
+t2bv_5.c t2bv_10.c t2bv_20.c t2bv_25.c
+)
+set(T3B t3bv_4.c t3bv_8.c t3bv_16.c t3bv_32.c
+t3bv_5.c t3bv_10.c t3bv_20.c t3bv_25.c
+)
+set(T1BU t1buv_2.c t1buv_3.c t1buv_4.c t1buv_5.c t1buv_6.c t1buv_7.c
+t1buv_8.c t1buv_9.c t1buv_10.c
+)
+
+# split-complex codelets
+set(T1S t1sv_2.c t1sv_4.c t1sv_8.c t1sv_16.c t1sv_32.c #t1sv_64.c
+)
+set(T2S t2sv_4.c t2sv_8.c t2sv_16.c t2sv_32.c #t2sv_64.c
+)
+
+###########################################################################
+# q1fv_<r> is <r> twiddle FFTW_FORWARD FFTs of size <r> (DIF step),
+# where the output is transposed, using SIMD.  This is used for
+# in-place transposes in sizes that are divisible by <r>^2.  These
+# codelets have size ~ <r>^2, so you should probably not use <r>
+# bigger than 8 or so.
+set(Q1F q1fv_2.c q1fv_4.c q1fv_5.c q1fv_8.c )
+
+# as above, but FFTW_BACKWARD
+set(Q1B q1bv_2.c q1bv_4.c q1bv_5.c q1bv_8.c)
+
+###########################################################################
+set(SIMD_CODELETS ${N1F} ${N1B} ${N2F} ${N2B} ${N2S} ${T1FU} ${T1F} ${T2F} ${T3F} ${T1BU} ${T1B} ${T2B} ${T3B} ${T1S} ${T2S} ${Q1F} ${Q1B})
+
+if(HAVE_SIMD)
+    set(ALL_CODELETS ${SIMD_CODELETS})
+else(HAVE_SIMD)
+    set(ALL_CODELETS)
+endif(HAVE_SIMD)
+
+set(SOLVTAB_NAME "X(solvtab_dft_simd)")
+set(CODLIST ${CMAKE_CURRENT_BINARY_DIR}/codlist.c)
+set(CODELET_NAME codelet_)
+
+set(dft_simd_codelets_SRCS ${ALL_CODELETS})
+
+# special rules for regenerating codelets.
+include(${CMAKE_SOURCE_DIR}/support/codelets.cmake)
+
+write_codelet_list(${CODLIST} ${CODELET_NAME} ${SOLVTAB_NAME} ${ALL_CODELETS})
+
+if(BUILD_ALL_STATIC)
+    add_library(dft_simd_codelets STATIC ${ALL_CODELETS})
+else(BUILD_ALL_STATIC)
+    prepend_prefix(dft_simd_codelets_SRCS)
+    set(__fftw_SRCS ${__fftw_SRCS} ${dft_simd_codelets_SRCS} ${CODLIST} PARENT_SCOPE)
+endif(BUILD_ALL_STATIC)
+
+#include $(top_srcdir)/support/Makefile.codelets
+
+#if MAINTAINER_MODE
+#GFLAGS = -simd $(FLAGS_COMMON) -pipeline-latency 8
+#FLAGS_T2S=-twiddle-log3 -precompute-twiddles
+#FLAGS_T3=-twiddle-log3 -precompute-twiddles -no-generate-bytw
+#
+#n1fv_%.c:  $(CODELET_DEPS) $(GEN_NOTW_C)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_NOTW_C) $(GFLAGS) -n $* -name n1fv_$* -include "n1f.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#n2fv_%.c:  $(CODELET_DEPS) $(GEN_NOTW_C)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_NOTW_C) $(GFLAGS) -n $* -name n2fv_$* -with-ostride 2 -include "n2f.h" -store-multiple 2) | $(ADD_DATE) | $(INDENT) >$@
+#
+#n1bv_%.c:  $(CODELET_DEPS) $(GEN_NOTW_C)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_NOTW_C) $(GFLAGS) -sign 1 -n $* -name n1bv_$* -include "n1b.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#n2bv_%.c:  $(CODELET_DEPS) $(GEN_NOTW_C)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_NOTW_C) $(GFLAGS) -sign 1 -n $* -name n2bv_$* -with-ostride 2 -include "n2b.h"  -store-multiple 2) | $(ADD_DATE) | $(INDENT) >$@
+#
+#n2sv_%.c:  $(CODELET_DEPS) $(GEN_NOTW)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_NOTW) $(GFLAGS) -n $* -name n2sv_$* -with-ostride 1 -include "n2s.h" -store-multiple 4) | $(ADD_DATE) | $(INDENT) >$@
+#
+#t1fv_%.c:  $(CODELET_DEPS) $(GEN_TWIDDLE_C)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_TWIDDLE_C) $(GFLAGS) -n $* -name t1fv_$* -include "t1f.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#t1fuv_%.c:  $(CODELET_DEPS) $(GEN_TWIDDLE_C)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_TWIDDLE_C) $(GFLAGS) -n $* -name t1fuv_$* -include "t1fu.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#t2fv_%.c:  $(CODELET_DEPS) $(GEN_TWIDDLE_C)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_TWIDDLE_C) $(GFLAGS) -n $* -name t2fv_$* -include "t2f.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#t3fv_%.c:  $(CODELET_DEPS) $(GEN_TWIDDLE_C)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_TWIDDLE_C) $(GFLAGS) $(FLAGS_T3) -n $* -name t3fv_$* -include "t3f.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#t1bv_%.c:  $(CODELET_DEPS) $(GEN_TWIDDLE_C)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_TWIDDLE_C) $(GFLAGS) -n $* -name t1bv_$* -include "t1b.h" -sign 1) | $(ADD_DATE) | $(INDENT) >$@
+#
+#t1buv_%.c:  $(CODELET_DEPS) $(GEN_TWIDDLE_C)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_TWIDDLE_C) $(GFLAGS) -n $* -name t1buv_$* -include "t1bu.h" -sign 1) | $(ADD_DATE) | $(INDENT) >$@
+#
+#t2bv_%.c:  $(CODELET_DEPS) $(GEN_TWIDDLE_C)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_TWIDDLE_C) $(GFLAGS) -n $* -name t2bv_$* -include "t2b.h" -sign 1) | $(ADD_DATE) | $(INDENT) >$@
+#
+#t3bv_%.c:  $(CODELET_DEPS) $(GEN_TWIDDLE_C)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_TWIDDLE_C) $(GFLAGS) $(FLAGS_T3) -n $* -name t3bv_$* -include "t3b.h" -sign 1) | $(ADD_DATE) | $(INDENT) >$@
+#
+#t1sv_%.c:  $(CODELET_DEPS) $(GEN_TWIDDLE)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_TWIDDLE) $(GFLAGS) -n $* -name t1sv_$* -include "ts.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#t2sv_%.c:  $(CODELET_DEPS) $(GEN_TWIDDLE)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_TWIDDLE) $(GFLAGS) $(FLAGS_T2S) -n $* -name t2sv_$* -include "ts.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#q1fv_%.c:  $(CODELET_DEPS) $(GEN_TWIDSQ_C)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_TWIDSQ_C) $(GFLAGS) -n $* -dif -name q1fv_$* -include "q1f.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#q1bv_%.c:  $(CODELET_DEPS) $(GEN_TWIDSQ_C)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_TWIDSQ_C) $(GFLAGS) -n $* -dif -name q1bv_$* -include "q1b.h" -sign 1) | $(ADD_DATE) | $(INDENT) >$@
+#
+#
+#endif # MAINTAINER_MODE
+#
diff --git a/fftw.def.cmake b/fftw.def.cmake
new file mode 100644
index 0000000..66e0cbe
--- /dev/null
+++ b/fftw.def.cmake
@@ -0,0 +1,808 @@
+EXPORTS
+@FFTW_SYMBOL_PREFIX@alignment_of
+@FFTW_SYMBOL_PREFIX@assertion_failed
+@FFTW_SYMBOL_PREFIX@bufdist
+@FFTW_SYMBOL_PREFIX@check_alignment_of_sse_pmpm
+@FFTW_SYMBOL_PREFIX@choose_radix
+@FFTW_SYMBOL_PREFIX@cleanup
+@FFTW_SYMBOL_PREFIX@cleanup_threads
+@FFTW_SYMBOL_PREFIX@codelet_e01_8
+@FFTW_SYMBOL_PREFIX@codelet_e10_8
+@FFTW_SYMBOL_PREFIX@codelet_hb2_16
+@FFTW_SYMBOL_PREFIX@codelet_hb2_20
+@FFTW_SYMBOL_PREFIX@codelet_hb2_25
+@FFTW_SYMBOL_PREFIX@codelet_hb2_32
+@FFTW_SYMBOL_PREFIX@codelet_hb2_4
+@FFTW_SYMBOL_PREFIX@codelet_hb2_5
+@FFTW_SYMBOL_PREFIX@codelet_hb2_8
+@FFTW_SYMBOL_PREFIX@codelet_hb_10
+@FFTW_SYMBOL_PREFIX@codelet_hb_12
+@FFTW_SYMBOL_PREFIX@codelet_hb_15
+@FFTW_SYMBOL_PREFIX@codelet_hb_16
+@FFTW_SYMBOL_PREFIX@codelet_hb_2
+@FFTW_SYMBOL_PREFIX@codelet_hb_20
+@FFTW_SYMBOL_PREFIX@codelet_hb_25
+@FFTW_SYMBOL_PREFIX@codelet_hb_3
+@FFTW_SYMBOL_PREFIX@codelet_hb_32
+@FFTW_SYMBOL_PREFIX@codelet_hb_4
+@FFTW_SYMBOL_PREFIX@codelet_hb_5
+@FFTW_SYMBOL_PREFIX@codelet_hb_6
+@FFTW_SYMBOL_PREFIX@codelet_hb_64
+@FFTW_SYMBOL_PREFIX@codelet_hb_7
+@FFTW_SYMBOL_PREFIX@codelet_hb_8
+@FFTW_SYMBOL_PREFIX@codelet_hb_9
+@FFTW_SYMBOL_PREFIX@codelet_hc2cb2_16
+@FFTW_SYMBOL_PREFIX@codelet_hc2cb2_20
+@FFTW_SYMBOL_PREFIX@codelet_hc2cb2_32
+@FFTW_SYMBOL_PREFIX@codelet_hc2cb2_4
+@FFTW_SYMBOL_PREFIX@codelet_hc2cb2_8
+@FFTW_SYMBOL_PREFIX@codelet_hc2cb_10
+@FFTW_SYMBOL_PREFIX@codelet_hc2cb_12
+@FFTW_SYMBOL_PREFIX@codelet_hc2cb_16
+@FFTW_SYMBOL_PREFIX@codelet_hc2cb_2
+@FFTW_SYMBOL_PREFIX@codelet_hc2cb_20
+@FFTW_SYMBOL_PREFIX@codelet_hc2cb_32
+@FFTW_SYMBOL_PREFIX@codelet_hc2cb_4
+@FFTW_SYMBOL_PREFIX@codelet_hc2cb_6
+@FFTW_SYMBOL_PREFIX@codelet_hc2cb_8
+@FFTW_SYMBOL_PREFIX@codelet_hc2cbdft2_16
+@FFTW_SYMBOL_PREFIX@codelet_hc2cbdft2_20
+@FFTW_SYMBOL_PREFIX@codelet_hc2cbdft2_32
+@FFTW_SYMBOL_PREFIX@codelet_hc2cbdft2_4
+@FFTW_SYMBOL_PREFIX@codelet_hc2cbdft2_8
+@FFTW_SYMBOL_PREFIX@codelet_hc2cbdft_10
+@FFTW_SYMBOL_PREFIX@codelet_hc2cbdft_12
+@FFTW_SYMBOL_PREFIX@codelet_hc2cbdft_16
+@FFTW_SYMBOL_PREFIX@codelet_hc2cbdft_2
+@FFTW_SYMBOL_PREFIX@codelet_hc2cbdft_20
+@FFTW_SYMBOL_PREFIX@codelet_hc2cbdft_32
+@FFTW_SYMBOL_PREFIX@codelet_hc2cbdft_4
+@FFTW_SYMBOL_PREFIX@codelet_hc2cbdft_6
+@FFTW_SYMBOL_PREFIX@codelet_hc2cbdft_8
+@FFTW_SYMBOL_PREFIX@codelet_hc2cbdftv_10
+@FFTW_SYMBOL_PREFIX@codelet_hc2cbdftv_12
+@FFTW_SYMBOL_PREFIX@codelet_hc2cbdftv_16
+@FFTW_SYMBOL_PREFIX@codelet_hc2cbdftv_2
+@FFTW_SYMBOL_PREFIX@codelet_hc2cbdftv_20
+@FFTW_SYMBOL_PREFIX@codelet_hc2cbdftv_32
+@FFTW_SYMBOL_PREFIX@codelet_hc2cbdftv_4
+@FFTW_SYMBOL_PREFIX@codelet_hc2cbdftv_6
+@FFTW_SYMBOL_PREFIX@codelet_hc2cbdftv_8
+@FFTW_SYMBOL_PREFIX@codelet_hc2cf2_16
+@FFTW_SYMBOL_PREFIX@codelet_hc2cf2_20
+@FFTW_SYMBOL_PREFIX@codelet_hc2cf2_32
+@FFTW_SYMBOL_PREFIX@codelet_hc2cf2_4
+@FFTW_SYMBOL_PREFIX@codelet_hc2cf2_8
+@FFTW_SYMBOL_PREFIX@codelet_hc2cf_10
+@FFTW_SYMBOL_PREFIX@codelet_hc2cf_12
+@FFTW_SYMBOL_PREFIX@codelet_hc2cf_16
+@FFTW_SYMBOL_PREFIX@codelet_hc2cf_2
+@FFTW_SYMBOL_PREFIX@codelet_hc2cf_20
+@FFTW_SYMBOL_PREFIX@codelet_hc2cf_32
+@FFTW_SYMBOL_PREFIX@codelet_hc2cf_4
+@FFTW_SYMBOL_PREFIX@codelet_hc2cf_6
+@FFTW_SYMBOL_PREFIX@codelet_hc2cf_8
+@FFTW_SYMBOL_PREFIX@codelet_hc2cfdft2_16
+@FFTW_SYMBOL_PREFIX@codelet_hc2cfdft2_20
+@FFTW_SYMBOL_PREFIX@codelet_hc2cfdft2_32
+@FFTW_SYMBOL_PREFIX@codelet_hc2cfdft2_4
+@FFTW_SYMBOL_PREFIX@codelet_hc2cfdft2_8
+@FFTW_SYMBOL_PREFIX@codelet_hc2cfdft_10
+@FFTW_SYMBOL_PREFIX@codelet_hc2cfdft_12
+@FFTW_SYMBOL_PREFIX@codelet_hc2cfdft_16
+@FFTW_SYMBOL_PREFIX@codelet_hc2cfdft_2
+@FFTW_SYMBOL_PREFIX@codelet_hc2cfdft_20
+@FFTW_SYMBOL_PREFIX@codelet_hc2cfdft_32
+@FFTW_SYMBOL_PREFIX@codelet_hc2cfdft_4
+@FFTW_SYMBOL_PREFIX@codelet_hc2cfdft_6
+@FFTW_SYMBOL_PREFIX@codelet_hc2cfdft_8
+@FFTW_SYMBOL_PREFIX@codelet_hc2cfdftv_10
+@FFTW_SYMBOL_PREFIX@codelet_hc2cfdftv_12
+@FFTW_SYMBOL_PREFIX@codelet_hc2cfdftv_16
+@FFTW_SYMBOL_PREFIX@codelet_hc2cfdftv_2
+@FFTW_SYMBOL_PREFIX@codelet_hc2cfdftv_20
+@FFTW_SYMBOL_PREFIX@codelet_hc2cfdftv_32
+@FFTW_SYMBOL_PREFIX@codelet_hc2cfdftv_4
+@FFTW_SYMBOL_PREFIX@codelet_hc2cfdftv_6
+@FFTW_SYMBOL_PREFIX@codelet_hc2cfdftv_8
+@FFTW_SYMBOL_PREFIX@codelet_hf2_16
+@FFTW_SYMBOL_PREFIX@codelet_hf2_20
+@FFTW_SYMBOL_PREFIX@codelet_hf2_25
+@FFTW_SYMBOL_PREFIX@codelet_hf2_32
+@FFTW_SYMBOL_PREFIX@codelet_hf2_4
+@FFTW_SYMBOL_PREFIX@codelet_hf2_5
+@FFTW_SYMBOL_PREFIX@codelet_hf2_8
+@FFTW_SYMBOL_PREFIX@codelet_hf_10
+@FFTW_SYMBOL_PREFIX@codelet_hf_12
+@FFTW_SYMBOL_PREFIX@codelet_hf_15
+@FFTW_SYMBOL_PREFIX@codelet_hf_16
+@FFTW_SYMBOL_PREFIX@codelet_hf_2
+@FFTW_SYMBOL_PREFIX@codelet_hf_20
+@FFTW_SYMBOL_PREFIX@codelet_hf_25
+@FFTW_SYMBOL_PREFIX@codelet_hf_3
+@FFTW_SYMBOL_PREFIX@codelet_hf_32
+@FFTW_SYMBOL_PREFIX@codelet_hf_4
+@FFTW_SYMBOL_PREFIX@codelet_hf_5
+@FFTW_SYMBOL_PREFIX@codelet_hf_6
+@FFTW_SYMBOL_PREFIX@codelet_hf_64
+@FFTW_SYMBOL_PREFIX@codelet_hf_7
+@FFTW_SYMBOL_PREFIX@codelet_hf_8
+@FFTW_SYMBOL_PREFIX@codelet_hf_9
+@FFTW_SYMBOL_PREFIX@codelet_n1_10
+@FFTW_SYMBOL_PREFIX@codelet_n1_11
+@FFTW_SYMBOL_PREFIX@codelet_n1_12
+@FFTW_SYMBOL_PREFIX@codelet_n1_13
+@FFTW_SYMBOL_PREFIX@codelet_n1_14
+@FFTW_SYMBOL_PREFIX@codelet_n1_15
+@FFTW_SYMBOL_PREFIX@codelet_n1_16
+@FFTW_SYMBOL_PREFIX@codelet_n1_2
+@FFTW_SYMBOL_PREFIX@codelet_n1_20
+@FFTW_SYMBOL_PREFIX@codelet_n1_25
+@FFTW_SYMBOL_PREFIX@codelet_n1_3
+@FFTW_SYMBOL_PREFIX@codelet_n1_32
+@FFTW_SYMBOL_PREFIX@codelet_n1_4
+@FFTW_SYMBOL_PREFIX@codelet_n1_5
+@FFTW_SYMBOL_PREFIX@codelet_n1_6
+@FFTW_SYMBOL_PREFIX@codelet_n1_64
+@FFTW_SYMBOL_PREFIX@codelet_n1_7
+@FFTW_SYMBOL_PREFIX@codelet_n1_8
+@FFTW_SYMBOL_PREFIX@codelet_n1_9
+@FFTW_SYMBOL_PREFIX@codelet_n1bv_10
+@FFTW_SYMBOL_PREFIX@codelet_n1bv_11
+@FFTW_SYMBOL_PREFIX@codelet_n1bv_12
+@FFTW_SYMBOL_PREFIX@codelet_n1bv_128
+@FFTW_SYMBOL_PREFIX@codelet_n1bv_13
+@FFTW_SYMBOL_PREFIX@codelet_n1bv_14
+@FFTW_SYMBOL_PREFIX@codelet_n1bv_15
+@FFTW_SYMBOL_PREFIX@codelet_n1bv_16
+@FFTW_SYMBOL_PREFIX@codelet_n1bv_2
+@FFTW_SYMBOL_PREFIX@codelet_n1bv_20
+@FFTW_SYMBOL_PREFIX@codelet_n1bv_25
+@FFTW_SYMBOL_PREFIX@codelet_n1bv_3
+@FFTW_SYMBOL_PREFIX@codelet_n1bv_32
+@FFTW_SYMBOL_PREFIX@codelet_n1bv_4
+@FFTW_SYMBOL_PREFIX@codelet_n1bv_5
+@FFTW_SYMBOL_PREFIX@codelet_n1bv_6
+@FFTW_SYMBOL_PREFIX@codelet_n1bv_64
+@FFTW_SYMBOL_PREFIX@codelet_n1bv_7
+@FFTW_SYMBOL_PREFIX@codelet_n1bv_8
+@FFTW_SYMBOL_PREFIX@codelet_n1bv_9
+@FFTW_SYMBOL_PREFIX@codelet_n1fv_10
+@FFTW_SYMBOL_PREFIX@codelet_n1fv_11
+@FFTW_SYMBOL_PREFIX@codelet_n1fv_12
+@FFTW_SYMBOL_PREFIX@codelet_n1fv_128
+@FFTW_SYMBOL_PREFIX@codelet_n1fv_13
+@FFTW_SYMBOL_PREFIX@codelet_n1fv_14
+@FFTW_SYMBOL_PREFIX@codelet_n1fv_15
+@FFTW_SYMBOL_PREFIX@codelet_n1fv_16
+@FFTW_SYMBOL_PREFIX@codelet_n1fv_2
+@FFTW_SYMBOL_PREFIX@codelet_n1fv_20
+@FFTW_SYMBOL_PREFIX@codelet_n1fv_25
+@FFTW_SYMBOL_PREFIX@codelet_n1fv_3
+@FFTW_SYMBOL_PREFIX@codelet_n1fv_32
+@FFTW_SYMBOL_PREFIX@codelet_n1fv_4
+@FFTW_SYMBOL_PREFIX@codelet_n1fv_5
+@FFTW_SYMBOL_PREFIX@codelet_n1fv_6
+@FFTW_SYMBOL_PREFIX@codelet_n1fv_64
+@FFTW_SYMBOL_PREFIX@codelet_n1fv_7
+@FFTW_SYMBOL_PREFIX@codelet_n1fv_8
+@FFTW_SYMBOL_PREFIX@codelet_n1fv_9
+@FFTW_SYMBOL_PREFIX@codelet_n2bv_10
+@FFTW_SYMBOL_PREFIX@codelet_n2bv_12
+@FFTW_SYMBOL_PREFIX@codelet_n2bv_14
+@FFTW_SYMBOL_PREFIX@codelet_n2bv_16
+@FFTW_SYMBOL_PREFIX@codelet_n2bv_2
+@FFTW_SYMBOL_PREFIX@codelet_n2bv_20
+@FFTW_SYMBOL_PREFIX@codelet_n2bv_32
+@FFTW_SYMBOL_PREFIX@codelet_n2bv_4
+@FFTW_SYMBOL_PREFIX@codelet_n2bv_6
+@FFTW_SYMBOL_PREFIX@codelet_n2bv_64
+@FFTW_SYMBOL_PREFIX@codelet_n2bv_8
+@FFTW_SYMBOL_PREFIX@codelet_n2fv_10
+@FFTW_SYMBOL_PREFIX@codelet_n2fv_12
+@FFTW_SYMBOL_PREFIX@codelet_n2fv_14
+@FFTW_SYMBOL_PREFIX@codelet_n2fv_16
+@FFTW_SYMBOL_PREFIX@codelet_n2fv_2
+@FFTW_SYMBOL_PREFIX@codelet_n2fv_20
+@FFTW_SYMBOL_PREFIX@codelet_n2fv_32
+@FFTW_SYMBOL_PREFIX@codelet_n2fv_4
+@FFTW_SYMBOL_PREFIX@codelet_n2fv_6
+@FFTW_SYMBOL_PREFIX@codelet_n2fv_64
+@FFTW_SYMBOL_PREFIX@codelet_n2fv_8
+@FFTW_SYMBOL_PREFIX@codelet_n2sv_16
+@FFTW_SYMBOL_PREFIX@codelet_n2sv_32
+@FFTW_SYMBOL_PREFIX@codelet_n2sv_4
+@FFTW_SYMBOL_PREFIX@codelet_n2sv_64
+@FFTW_SYMBOL_PREFIX@codelet_n2sv_8
+@FFTW_SYMBOL_PREFIX@codelet_q1_2
+@FFTW_SYMBOL_PREFIX@codelet_q1_3
+@FFTW_SYMBOL_PREFIX@codelet_q1_4
+@FFTW_SYMBOL_PREFIX@codelet_q1_5
+@FFTW_SYMBOL_PREFIX@codelet_q1_6
+@FFTW_SYMBOL_PREFIX@codelet_q1_8
+@FFTW_SYMBOL_PREFIX@codelet_q1bv_2
+@FFTW_SYMBOL_PREFIX@codelet_q1bv_4
+@FFTW_SYMBOL_PREFIX@codelet_q1bv_5
+@FFTW_SYMBOL_PREFIX@codelet_q1bv_8
+@FFTW_SYMBOL_PREFIX@codelet_q1fv_2
+@FFTW_SYMBOL_PREFIX@codelet_q1fv_4
+@FFTW_SYMBOL_PREFIX@codelet_q1fv_5
+@FFTW_SYMBOL_PREFIX@codelet_q1fv_8
+@FFTW_SYMBOL_PREFIX@codelet_r2cbIII_10
+@FFTW_SYMBOL_PREFIX@codelet_r2cbIII_12
+@FFTW_SYMBOL_PREFIX@codelet_r2cbIII_15
+@FFTW_SYMBOL_PREFIX@codelet_r2cbIII_16
+@FFTW_SYMBOL_PREFIX@codelet_r2cbIII_2
+@FFTW_SYMBOL_PREFIX@codelet_r2cbIII_20
+@FFTW_SYMBOL_PREFIX@codelet_r2cbIII_25
+@FFTW_SYMBOL_PREFIX@codelet_r2cbIII_3
+@FFTW_SYMBOL_PREFIX@codelet_r2cbIII_32
+@FFTW_SYMBOL_PREFIX@codelet_r2cbIII_4
+@FFTW_SYMBOL_PREFIX@codelet_r2cbIII_5
+@FFTW_SYMBOL_PREFIX@codelet_r2cbIII_6
+@FFTW_SYMBOL_PREFIX@codelet_r2cbIII_64
+@FFTW_SYMBOL_PREFIX@codelet_r2cbIII_7
+@FFTW_SYMBOL_PREFIX@codelet_r2cbIII_8
+@FFTW_SYMBOL_PREFIX@codelet_r2cbIII_9
+@FFTW_SYMBOL_PREFIX@codelet_r2cb_10
+@FFTW_SYMBOL_PREFIX@codelet_r2cb_11
+@FFTW_SYMBOL_PREFIX@codelet_r2cb_12
+@FFTW_SYMBOL_PREFIX@codelet_r2cb_128
+@FFTW_SYMBOL_PREFIX@codelet_r2cb_13
+@FFTW_SYMBOL_PREFIX@codelet_r2cb_14
+@FFTW_SYMBOL_PREFIX@codelet_r2cb_15
+@FFTW_SYMBOL_PREFIX@codelet_r2cb_16
+@FFTW_SYMBOL_PREFIX@codelet_r2cb_2
+@FFTW_SYMBOL_PREFIX@codelet_r2cb_20
+@FFTW_SYMBOL_PREFIX@codelet_r2cb_25
+@FFTW_SYMBOL_PREFIX@codelet_r2cb_3
+@FFTW_SYMBOL_PREFIX@codelet_r2cb_32
+@FFTW_SYMBOL_PREFIX@codelet_r2cb_4
+@FFTW_SYMBOL_PREFIX@codelet_r2cb_5
+@FFTW_SYMBOL_PREFIX@codelet_r2cb_6
+@FFTW_SYMBOL_PREFIX@codelet_r2cb_64
+@FFTW_SYMBOL_PREFIX@codelet_r2cb_7
+@FFTW_SYMBOL_PREFIX@codelet_r2cb_8
+@FFTW_SYMBOL_PREFIX@codelet_r2cb_9
+@FFTW_SYMBOL_PREFIX@codelet_r2cfII_10
+@FFTW_SYMBOL_PREFIX@codelet_r2cfII_12
+@FFTW_SYMBOL_PREFIX@codelet_r2cfII_15
+@FFTW_SYMBOL_PREFIX@codelet_r2cfII_16
+@FFTW_SYMBOL_PREFIX@codelet_r2cfII_2
+@FFTW_SYMBOL_PREFIX@codelet_r2cfII_20
+@FFTW_SYMBOL_PREFIX@codelet_r2cfII_25
+@FFTW_SYMBOL_PREFIX@codelet_r2cfII_3
+@FFTW_SYMBOL_PREFIX@codelet_r2cfII_32
+@FFTW_SYMBOL_PREFIX@codelet_r2cfII_4
+@FFTW_SYMBOL_PREFIX@codelet_r2cfII_5
+@FFTW_SYMBOL_PREFIX@codelet_r2cfII_6
+@FFTW_SYMBOL_PREFIX@codelet_r2cfII_64
+@FFTW_SYMBOL_PREFIX@codelet_r2cfII_7
+@FFTW_SYMBOL_PREFIX@codelet_r2cfII_8
+@FFTW_SYMBOL_PREFIX@codelet_r2cfII_9
+@FFTW_SYMBOL_PREFIX@codelet_r2cf_10
+@FFTW_SYMBOL_PREFIX@codelet_r2cf_11
+@FFTW_SYMBOL_PREFIX@codelet_r2cf_12
+@FFTW_SYMBOL_PREFIX@codelet_r2cf_128
+@FFTW_SYMBOL_PREFIX@codelet_r2cf_13
+@FFTW_SYMBOL_PREFIX@codelet_r2cf_14
+@FFTW_SYMBOL_PREFIX@codelet_r2cf_15
+@FFTW_SYMBOL_PREFIX@codelet_r2cf_16
+@FFTW_SYMBOL_PREFIX@codelet_r2cf_2
+@FFTW_SYMBOL_PREFIX@codelet_r2cf_20
+@FFTW_SYMBOL_PREFIX@codelet_r2cf_25
+@FFTW_SYMBOL_PREFIX@codelet_r2cf_3
+@FFTW_SYMBOL_PREFIX@codelet_r2cf_32
+@FFTW_SYMBOL_PREFIX@codelet_r2cf_4
+@FFTW_SYMBOL_PREFIX@codelet_r2cf_5
+@FFTW_SYMBOL_PREFIX@codelet_r2cf_6
+@FFTW_SYMBOL_PREFIX@codelet_r2cf_64
+@FFTW_SYMBOL_PREFIX@codelet_r2cf_7
+@FFTW_SYMBOL_PREFIX@codelet_r2cf_8
+@FFTW_SYMBOL_PREFIX@codelet_r2cf_9
+@FFTW_SYMBOL_PREFIX@codelet_t1_10
+@FFTW_SYMBOL_PREFIX@codelet_t1_12
+@FFTW_SYMBOL_PREFIX@codelet_t1_15
+@FFTW_SYMBOL_PREFIX@codelet_t1_16
+@FFTW_SYMBOL_PREFIX@codelet_t1_2
+@FFTW_SYMBOL_PREFIX@codelet_t1_20
+@FFTW_SYMBOL_PREFIX@codelet_t1_25
+@FFTW_SYMBOL_PREFIX@codelet_t1_3
+@FFTW_SYMBOL_PREFIX@codelet_t1_32
+@FFTW_SYMBOL_PREFIX@codelet_t1_4
+@FFTW_SYMBOL_PREFIX@codelet_t1_5
+@FFTW_SYMBOL_PREFIX@codelet_t1_6
+@FFTW_SYMBOL_PREFIX@codelet_t1_64
+@FFTW_SYMBOL_PREFIX@codelet_t1_7
+@FFTW_SYMBOL_PREFIX@codelet_t1_8
+@FFTW_SYMBOL_PREFIX@codelet_t1_9
+@FFTW_SYMBOL_PREFIX@codelet_t1buv_10
+@FFTW_SYMBOL_PREFIX@codelet_t1buv_2
+@FFTW_SYMBOL_PREFIX@codelet_t1buv_3
+@FFTW_SYMBOL_PREFIX@codelet_t1buv_4
+@FFTW_SYMBOL_PREFIX@codelet_t1buv_5
+@FFTW_SYMBOL_PREFIX@codelet_t1buv_6
+@FFTW_SYMBOL_PREFIX@codelet_t1buv_7
+@FFTW_SYMBOL_PREFIX@codelet_t1buv_8
+@FFTW_SYMBOL_PREFIX@codelet_t1buv_9
+@FFTW_SYMBOL_PREFIX@codelet_t1bv_10
+@FFTW_SYMBOL_PREFIX@codelet_t1bv_12
+@FFTW_SYMBOL_PREFIX@codelet_t1bv_15
+@FFTW_SYMBOL_PREFIX@codelet_t1bv_16
+@FFTW_SYMBOL_PREFIX@codelet_t1bv_2
+@FFTW_SYMBOL_PREFIX@codelet_t1bv_20
+@FFTW_SYMBOL_PREFIX@codelet_t1bv_25
+@FFTW_SYMBOL_PREFIX@codelet_t1bv_3
+@FFTW_SYMBOL_PREFIX@codelet_t1bv_32
+@FFTW_SYMBOL_PREFIX@codelet_t1bv_4
+@FFTW_SYMBOL_PREFIX@codelet_t1bv_5
+@FFTW_SYMBOL_PREFIX@codelet_t1bv_6
+@FFTW_SYMBOL_PREFIX@codelet_t1bv_64
+@FFTW_SYMBOL_PREFIX@codelet_t1bv_7
+@FFTW_SYMBOL_PREFIX@codelet_t1bv_8
+@FFTW_SYMBOL_PREFIX@codelet_t1bv_9
+@FFTW_SYMBOL_PREFIX@codelet_t1fuv_10
+@FFTW_SYMBOL_PREFIX@codelet_t1fuv_2
+@FFTW_SYMBOL_PREFIX@codelet_t1fuv_3
+@FFTW_SYMBOL_PREFIX@codelet_t1fuv_4
+@FFTW_SYMBOL_PREFIX@codelet_t1fuv_5
+@FFTW_SYMBOL_PREFIX@codelet_t1fuv_6
+@FFTW_SYMBOL_PREFIX@codelet_t1fuv_7
+@FFTW_SYMBOL_PREFIX@codelet_t1fuv_8
+@FFTW_SYMBOL_PREFIX@codelet_t1fuv_9
+@FFTW_SYMBOL_PREFIX@codelet_t1fv_10
+@FFTW_SYMBOL_PREFIX@codelet_t1fv_12
+@FFTW_SYMBOL_PREFIX@codelet_t1fv_15
+@FFTW_SYMBOL_PREFIX@codelet_t1fv_16
+@FFTW_SYMBOL_PREFIX@codelet_t1fv_2
+@FFTW_SYMBOL_PREFIX@codelet_t1fv_20
+@FFTW_SYMBOL_PREFIX@codelet_t1fv_25
+@FFTW_SYMBOL_PREFIX@codelet_t1fv_3
+@FFTW_SYMBOL_PREFIX@codelet_t1fv_32
+@FFTW_SYMBOL_PREFIX@codelet_t1fv_4
+@FFTW_SYMBOL_PREFIX@codelet_t1fv_5
+@FFTW_SYMBOL_PREFIX@codelet_t1fv_6
+@FFTW_SYMBOL_PREFIX@codelet_t1fv_64
+@FFTW_SYMBOL_PREFIX@codelet_t1fv_7
+@FFTW_SYMBOL_PREFIX@codelet_t1fv_8
+@FFTW_SYMBOL_PREFIX@codelet_t1fv_9
+@FFTW_SYMBOL_PREFIX@codelet_t1sv_16
+@FFTW_SYMBOL_PREFIX@codelet_t1sv_2
+@FFTW_SYMBOL_PREFIX@codelet_t1sv_32
+@FFTW_SYMBOL_PREFIX@codelet_t1sv_4
+@FFTW_SYMBOL_PREFIX@codelet_t1sv_8
+@FFTW_SYMBOL_PREFIX@codelet_t2_10
+@FFTW_SYMBOL_PREFIX@codelet_t2_16
+@FFTW_SYMBOL_PREFIX@codelet_t2_20
+@FFTW_SYMBOL_PREFIX@codelet_t2_25
+@FFTW_SYMBOL_PREFIX@codelet_t2_32
+@FFTW_SYMBOL_PREFIX@codelet_t2_4
+@FFTW_SYMBOL_PREFIX@codelet_t2_5
+@FFTW_SYMBOL_PREFIX@codelet_t2_64
+@FFTW_SYMBOL_PREFIX@codelet_t2_8
+@FFTW_SYMBOL_PREFIX@codelet_t2bv_10
+@FFTW_SYMBOL_PREFIX@codelet_t2bv_16
+@FFTW_SYMBOL_PREFIX@codelet_t2bv_2
+@FFTW_SYMBOL_PREFIX@codelet_t2bv_20
+@FFTW_SYMBOL_PREFIX@codelet_t2bv_25
+@FFTW_SYMBOL_PREFIX@codelet_t2bv_32
+@FFTW_SYMBOL_PREFIX@codelet_t2bv_4
+@FFTW_SYMBOL_PREFIX@codelet_t2bv_5
+@FFTW_SYMBOL_PREFIX@codelet_t2bv_64
+@FFTW_SYMBOL_PREFIX@codelet_t2bv_8
+@FFTW_SYMBOL_PREFIX@codelet_t2fv_10
+@FFTW_SYMBOL_PREFIX@codelet_t2fv_16
+@FFTW_SYMBOL_PREFIX@codelet_t2fv_2
+@FFTW_SYMBOL_PREFIX@codelet_t2fv_20
+@FFTW_SYMBOL_PREFIX@codelet_t2fv_25
+@FFTW_SYMBOL_PREFIX@codelet_t2fv_32
+@FFTW_SYMBOL_PREFIX@codelet_t2fv_4
+@FFTW_SYMBOL_PREFIX@codelet_t2fv_5
+@FFTW_SYMBOL_PREFIX@codelet_t2fv_64
+@FFTW_SYMBOL_PREFIX@codelet_t2fv_8
+@FFTW_SYMBOL_PREFIX@codelet_t2sv_16
+@FFTW_SYMBOL_PREFIX@codelet_t2sv_32
+@FFTW_SYMBOL_PREFIX@codelet_t2sv_4
+@FFTW_SYMBOL_PREFIX@codelet_t2sv_8
+@FFTW_SYMBOL_PREFIX@codelet_t3bv_10
+@FFTW_SYMBOL_PREFIX@codelet_t3bv_16
+@FFTW_SYMBOL_PREFIX@codelet_t3bv_20
+@FFTW_SYMBOL_PREFIX@codelet_t3bv_25
+@FFTW_SYMBOL_PREFIX@codelet_t3bv_32
+@FFTW_SYMBOL_PREFIX@codelet_t3bv_4
+@FFTW_SYMBOL_PREFIX@codelet_t3bv_5
+@FFTW_SYMBOL_PREFIX@codelet_t3bv_8
+@FFTW_SYMBOL_PREFIX@codelet_t3fv_10
+@FFTW_SYMBOL_PREFIX@codelet_t3fv_16
+@FFTW_SYMBOL_PREFIX@codelet_t3fv_20
+@FFTW_SYMBOL_PREFIX@codelet_t3fv_25
+@FFTW_SYMBOL_PREFIX@codelet_t3fv_32
+@FFTW_SYMBOL_PREFIX@codelet_t3fv_4
+@FFTW_SYMBOL_PREFIX@codelet_t3fv_5
+@FFTW_SYMBOL_PREFIX@codelet_t3fv_8
+@FFTW_SYMBOL_PREFIX@compute_tilesz
+@FFTW_SYMBOL_PREFIX@configure_planner
+@FFTW_SYMBOL_PREFIX@cpy1d
+@FFTW_SYMBOL_PREFIX@cpy2d
+@FFTW_SYMBOL_PREFIX@cpy2d_ci
+@FFTW_SYMBOL_PREFIX@cpy2d_co
+@FFTW_SYMBOL_PREFIX@cpy2d_pair
+@FFTW_SYMBOL_PREFIX@cpy2d_pair_ci
+@FFTW_SYMBOL_PREFIX@cpy2d_pair_co
+@FFTW_SYMBOL_PREFIX@cpy2d_tiled
+@FFTW_SYMBOL_PREFIX@cpy2d_tiledbuf
+@FFTW_SYMBOL_PREFIX@ct_applicable
+@FFTW_SYMBOL_PREFIX@ct_generic_register
+@FFTW_SYMBOL_PREFIX@ct_genericbuf_register
+@FFTW_SYMBOL_PREFIX@ct_uglyp
+@FFTW_SYMBOL_PREFIX@destroy_plan
+@FFTW_SYMBOL_PREFIX@dft_bluestein_register
+@FFTW_SYMBOL_PREFIX@dft_buffered_register
+@FFTW_SYMBOL_PREFIX@dft_conf_standard
+@FFTW_SYMBOL_PREFIX@dft_generic_register
+@FFTW_SYMBOL_PREFIX@dft_indirect_register
+@FFTW_SYMBOL_PREFIX@dft_indirect_transpose_register
+@FFTW_SYMBOL_PREFIX@dft_nop_register
+@FFTW_SYMBOL_PREFIX@dft_r2hc_register
+@FFTW_SYMBOL_PREFIX@dft_rader_register
+@FFTW_SYMBOL_PREFIX@dft_rank_geq2_register
+@FFTW_SYMBOL_PREFIX@dft_solve
+@FFTW_SYMBOL_PREFIX@dft_thr_vrank_geq1_register
+@FFTW_SYMBOL_PREFIX@dft_vrank_geq1_register
+@FFTW_SYMBOL_PREFIX@dft_zerotens
+@FFTW_SYMBOL_PREFIX@dht_r2hc_register
+@FFTW_SYMBOL_PREFIX@dht_rader_register
+@FFTW_SYMBOL_PREFIX@dimcmp
+@FFTW_SYMBOL_PREFIX@elapsed_since
+@FFTW_SYMBOL_PREFIX@estimate_cost
+@FFTW_SYMBOL_PREFIX@execute
+@FFTW_SYMBOL_PREFIX@execute_dft
+@FFTW_SYMBOL_PREFIX@execute_dft_c2r
+@FFTW_SYMBOL_PREFIX@execute_dft_r2c
+@FFTW_SYMBOL_PREFIX@execute_r2r
+@FFTW_SYMBOL_PREFIX@execute_split_dft
+@FFTW_SYMBOL_PREFIX@execute_split_dft_c2r
+@FFTW_SYMBOL_PREFIX@execute_split_dft_r2c
+@FFTW_SYMBOL_PREFIX@export_wisdom
+@FFTW_SYMBOL_PREFIX@export_wisdom_to_file
+@FFTW_SYMBOL_PREFIX@export_wisdom_to_string
+@FFTW_SYMBOL_PREFIX@extract_reim
+@FFTW_SYMBOL_PREFIX@factors_into
+@FFTW_SYMBOL_PREFIX@find_generator
+@FFTW_SYMBOL_PREFIX@first_divisor
+@FFTW_SYMBOL_PREFIX@flops
+@FFTW_SYMBOL_PREFIX@forget_wisdom
+@FFTW_SYMBOL_PREFIX@fprint_plan
+@FFTW_SYMBOL_PREFIX@free
+@FFTW_SYMBOL_PREFIX@get_crude_time
+@FFTW_SYMBOL_PREFIX@guru64_kosherp
+@FFTW_SYMBOL_PREFIX@guru_kosherp
+@FFTW_SYMBOL_PREFIX@hash
+@FFTW_SYMBOL_PREFIX@have_sse
+@FFTW_SYMBOL_PREFIX@hc2c_applicable
+@FFTW_SYMBOL_PREFIX@hc2hc_applicable
+@FFTW_SYMBOL_PREFIX@hc2hc_generic_register
+@FFTW_SYMBOL_PREFIX@iabs
+@FFTW_SYMBOL_PREFIX@iestimate_cost
+@FFTW_SYMBOL_PREFIX@ifree
+@FFTW_SYMBOL_PREFIX@ifree0
+@FFTW_SYMBOL_PREFIX@imax
+@FFTW_SYMBOL_PREFIX@imin
+@FFTW_SYMBOL_PREFIX@import_system_wisdom
+@FFTW_SYMBOL_PREFIX@import_wisdom
+@FFTW_SYMBOL_PREFIX@import_wisdom_from_file
+@FFTW_SYMBOL_PREFIX@import_wisdom_from_string
+@FFTW_SYMBOL_PREFIX@init_threads
+@FFTW_SYMBOL_PREFIX@is_prime
+@FFTW_SYMBOL_PREFIX@isqrt
+@FFTW_SYMBOL_PREFIX@ithreads_init
+@FFTW_SYMBOL_PREFIX@join_taint
+@FFTW_SYMBOL_PREFIX@kdft_dif_register
+@FFTW_SYMBOL_PREFIX@kdft_difsq_register
+@FFTW_SYMBOL_PREFIX@kdft_dit_register
+@FFTW_SYMBOL_PREFIX@kdft_register
+@FFTW_SYMBOL_PREFIX@kernel_free
+@FFTW_SYMBOL_PREFIX@kernel_malloc
+@FFTW_SYMBOL_PREFIX@khc2c_register
+@FFTW_SYMBOL_PREFIX@khc2hc_register
+@FFTW_SYMBOL_PREFIX@kr2c_register
+@FFTW_SYMBOL_PREFIX@kr2r_register
+@FFTW_SYMBOL_PREFIX@malloc
+@FFTW_SYMBOL_PREFIX@malloc_plain
+@FFTW_SYMBOL_PREFIX@many_kosherp
+@FFTW_SYMBOL_PREFIX@map_r2r_kind
+@FFTW_SYMBOL_PREFIX@mapflags
+@FFTW_SYMBOL_PREFIX@md5INT
+@FFTW_SYMBOL_PREFIX@md5begin
+@FFTW_SYMBOL_PREFIX@md5end
+@FFTW_SYMBOL_PREFIX@md5int
+@FFTW_SYMBOL_PREFIX@md5putb
+@FFTW_SYMBOL_PREFIX@md5putc
+@FFTW_SYMBOL_PREFIX@md5puts
+@FFTW_SYMBOL_PREFIX@md5unsigned
+@FFTW_SYMBOL_PREFIX@measure_execution_time
+@FFTW_SYMBOL_PREFIX@mkapiplan
+@FFTW_SYMBOL_PREFIX@mkplan
+@FFTW_SYMBOL_PREFIX@mkplan_d
+@FFTW_SYMBOL_PREFIX@mkplan_dft
+@FFTW_SYMBOL_PREFIX@mkplan_dftw
+@FFTW_SYMBOL_PREFIX@mkplan_f_d
+@FFTW_SYMBOL_PREFIX@mkplan_hc2c
+@FFTW_SYMBOL_PREFIX@mkplan_hc2hc
+@FFTW_SYMBOL_PREFIX@mkplan_rdft
+@FFTW_SYMBOL_PREFIX@mkplan_rdft2
+@FFTW_SYMBOL_PREFIX@mkplanner
+@FFTW_SYMBOL_PREFIX@mkprinter
+@FFTW_SYMBOL_PREFIX@mkprinter_file
+@FFTW_SYMBOL_PREFIX@mkproblem
+@FFTW_SYMBOL_PREFIX@mkproblem_dft
+@FFTW_SYMBOL_PREFIX@mkproblem_dft_d
+@FFTW_SYMBOL_PREFIX@mkproblem_rdft
+@FFTW_SYMBOL_PREFIX@mkproblem_rdft2
+@FFTW_SYMBOL_PREFIX@mkproblem_rdft2_d
+@FFTW_SYMBOL_PREFIX@mkproblem_rdft2_d_3pointers
+@FFTW_SYMBOL_PREFIX@mkproblem_rdft_0_d
+@FFTW_SYMBOL_PREFIX@mkproblem_rdft_1
+@FFTW_SYMBOL_PREFIX@mkproblem_rdft_1_d
+@FFTW_SYMBOL_PREFIX@mkproblem_rdft_d
+@FFTW_SYMBOL_PREFIX@mkproblem_unsolvable
+@FFTW_SYMBOL_PREFIX@mkscanner
+@FFTW_SYMBOL_PREFIX@mksolver
+@FFTW_SYMBOL_PREFIX@mksolver_ct
+@FFTW_SYMBOL_PREFIX@mksolver_ct_threads
+@FFTW_SYMBOL_PREFIX@mksolver_dft_direct
+@FFTW_SYMBOL_PREFIX@mksolver_dft_directbuf
+@FFTW_SYMBOL_PREFIX@mksolver_hc2c
+@FFTW_SYMBOL_PREFIX@mksolver_hc2hc
+@FFTW_SYMBOL_PREFIX@mksolver_hc2hc_threads
+@FFTW_SYMBOL_PREFIX@mksolver_rdft2_direct
+@FFTW_SYMBOL_PREFIX@mksolver_rdft_r2c_direct
+@FFTW_SYMBOL_PREFIX@mksolver_rdft_r2c_directbuf
+@FFTW_SYMBOL_PREFIX@mksolver_rdft_r2r_direct
+@FFTW_SYMBOL_PREFIX@mkstride
+@FFTW_SYMBOL_PREFIX@mktensor
+@FFTW_SYMBOL_PREFIX@mktensor_0d
+@FFTW_SYMBOL_PREFIX@mktensor_1d
+@FFTW_SYMBOL_PREFIX@mktensor_2d
+@FFTW_SYMBOL_PREFIX@mktensor_3d
+@FFTW_SYMBOL_PREFIX@mktensor_4d
+@FFTW_SYMBOL_PREFIX@mktensor_5d
+@FFTW_SYMBOL_PREFIX@mktensor_iodims
+@FFTW_SYMBOL_PREFIX@mktensor_iodims64
+@FFTW_SYMBOL_PREFIX@mktensor_rowmajor
+@FFTW_SYMBOL_PREFIX@mktriggen
+@FFTW_SYMBOL_PREFIX@modulo
+@FFTW_SYMBOL_PREFIX@nbuf
+@FFTW_SYMBOL_PREFIX@nbuf_redundant
+@FFTW_SYMBOL_PREFIX@next_prime
+@FFTW_SYMBOL_PREFIX@null_awake
+@FFTW_SYMBOL_PREFIX@ops_add
+@FFTW_SYMBOL_PREFIX@ops_add2
+@FFTW_SYMBOL_PREFIX@ops_cpy
+@FFTW_SYMBOL_PREFIX@ops_madd
+@FFTW_SYMBOL_PREFIX@ops_madd2
+@FFTW_SYMBOL_PREFIX@ops_other
+@FFTW_SYMBOL_PREFIX@ops_zero
+@FFTW_SYMBOL_PREFIX@pickdim
+@FFTW_SYMBOL_PREFIX@plan_awake
+@FFTW_SYMBOL_PREFIX@plan_destroy_internal
+@FFTW_SYMBOL_PREFIX@plan_dft
+@FFTW_SYMBOL_PREFIX@plan_dft_1d
+@FFTW_SYMBOL_PREFIX@plan_dft_2d
+@FFTW_SYMBOL_PREFIX@plan_dft_3d
+@FFTW_SYMBOL_PREFIX@plan_dft_c2r
+@FFTW_SYMBOL_PREFIX@plan_dft_c2r_1d
+@FFTW_SYMBOL_PREFIX@plan_dft_c2r_2d
+@FFTW_SYMBOL_PREFIX@plan_dft_c2r_3d
+@FFTW_SYMBOL_PREFIX@plan_dft_r2c
+@FFTW_SYMBOL_PREFIX@plan_dft_r2c_1d
+@FFTW_SYMBOL_PREFIX@plan_dft_r2c_2d
+@FFTW_SYMBOL_PREFIX@plan_dft_r2c_3d
+@FFTW_SYMBOL_PREFIX@plan_guru64_dft
+@FFTW_SYMBOL_PREFIX@plan_guru64_dft_c2r
+@FFTW_SYMBOL_PREFIX@plan_guru64_dft_r2c
+@FFTW_SYMBOL_PREFIX@plan_guru64_r2r
+@FFTW_SYMBOL_PREFIX@plan_guru64_split_dft
+@FFTW_SYMBOL_PREFIX@plan_guru64_split_dft_c2r
+@FFTW_SYMBOL_PREFIX@plan_guru64_split_dft_r2c
+@FFTW_SYMBOL_PREFIX@plan_guru_dft
+@FFTW_SYMBOL_PREFIX@plan_guru_dft_c2r
+@FFTW_SYMBOL_PREFIX@plan_guru_dft_r2c
+@FFTW_SYMBOL_PREFIX@plan_guru_r2r
+@FFTW_SYMBOL_PREFIX@plan_guru_split_dft
+@FFTW_SYMBOL_PREFIX@plan_guru_split_dft_c2r
+@FFTW_SYMBOL_PREFIX@plan_guru_split_dft_r2c
+@FFTW_SYMBOL_PREFIX@plan_many_dft
+@FFTW_SYMBOL_PREFIX@plan_many_dft_c2r
+@FFTW_SYMBOL_PREFIX@plan_many_dft_r2c
+@FFTW_SYMBOL_PREFIX@plan_many_r2r
+@FFTW_SYMBOL_PREFIX@plan_null_destroy
+@FFTW_SYMBOL_PREFIX@plan_r2r
+@FFTW_SYMBOL_PREFIX@plan_r2r_1d
+@FFTW_SYMBOL_PREFIX@plan_r2r_2d
+@FFTW_SYMBOL_PREFIX@plan_r2r_3d
+@FFTW_SYMBOL_PREFIX@plan_with_nthreads
+@FFTW_SYMBOL_PREFIX@planner_destroy
+@FFTW_SYMBOL_PREFIX@power_mod
+@FFTW_SYMBOL_PREFIX@print_plan
+@FFTW_SYMBOL_PREFIX@printer_destroy
+@FFTW_SYMBOL_PREFIX@problem_destroy
+@FFTW_SYMBOL_PREFIX@rader_tl_delete
+@FFTW_SYMBOL_PREFIX@rader_tl_find
+@FFTW_SYMBOL_PREFIX@rader_tl_insert
+@FFTW_SYMBOL_PREFIX@rdft2_buffered_register
+@FFTW_SYMBOL_PREFIX@rdft2_complex_n
+@FFTW_SYMBOL_PREFIX@rdft2_inplace_strides
+@FFTW_SYMBOL_PREFIX@rdft2_nop_register
+@FFTW_SYMBOL_PREFIX@rdft2_pad
+@FFTW_SYMBOL_PREFIX@rdft2_rank0_register
+@FFTW_SYMBOL_PREFIX@rdft2_rank_geq2_register
+@FFTW_SYMBOL_PREFIX@rdft2_rdft_register
+@FFTW_SYMBOL_PREFIX@rdft2_solve
+@FFTW_SYMBOL_PREFIX@rdft2_strides
+@FFTW_SYMBOL_PREFIX@rdft2_tensor_max_index
+@FFTW_SYMBOL_PREFIX@rdft2_thr_vrank_geq1_register
+@FFTW_SYMBOL_PREFIX@rdft2_vrank_geq1_register
+@FFTW_SYMBOL_PREFIX@rdft_buffered_register
+@FFTW_SYMBOL_PREFIX@rdft_conf_standard
+@FFTW_SYMBOL_PREFIX@rdft_dht_register
+@FFTW_SYMBOL_PREFIX@rdft_generic_register
+@FFTW_SYMBOL_PREFIX@rdft_indirect_register
+@FFTW_SYMBOL_PREFIX@rdft_kind_str
+@FFTW_SYMBOL_PREFIX@rdft_nop_register
+@FFTW_SYMBOL_PREFIX@rdft_rank0_register
+@FFTW_SYMBOL_PREFIX@rdft_rank_geq2_register
+@FFTW_SYMBOL_PREFIX@rdft_solve
+@FFTW_SYMBOL_PREFIX@rdft_thr_vrank_geq1_register
+@FFTW_SYMBOL_PREFIX@rdft_vrank3_transpose_register
+@FFTW_SYMBOL_PREFIX@rdft_vrank_geq1_register
+@FFTW_SYMBOL_PREFIX@rdft_zerotens
+@FFTW_SYMBOL_PREFIX@redft00e_r2hc_pad_register
+@FFTW_SYMBOL_PREFIX@regsolver_ct_directw
+@FFTW_SYMBOL_PREFIX@regsolver_ct_directwsq
+@FFTW_SYMBOL_PREFIX@regsolver_hc2c_direct
+@FFTW_SYMBOL_PREFIX@regsolver_hc2hc_direct
+@FFTW_SYMBOL_PREFIX@reodft00e_splitradix_register
+@FFTW_SYMBOL_PREFIX@reodft010e_r2hc_register
+@FFTW_SYMBOL_PREFIX@reodft11e_r2hc_odd_register
+@FFTW_SYMBOL_PREFIX@reodft11e_radix2_r2hc_register
+@FFTW_SYMBOL_PREFIX@reodft_conf_standard
+@FFTW_SYMBOL_PREFIX@rodft00e_r2hc_pad_register
+@FFTW_SYMBOL_PREFIX@safe_mulmod
+@FFTW_SYMBOL_PREFIX@scanner_destroy
+@FFTW_SYMBOL_PREFIX@set_timelimit
+@FFTW_SYMBOL_PREFIX@solver_destroy
+@FFTW_SYMBOL_PREFIX@solver_register
+@FFTW_SYMBOL_PREFIX@solver_use
+@FFTW_SYMBOL_PREFIX@solvtab_exec
+@FFTW_SYMBOL_PREFIX@spawn_loop
+@FFTW_SYMBOL_PREFIX@stride_destroy
+@FFTW_SYMBOL_PREFIX@taint
+@FFTW_SYMBOL_PREFIX@tensor_append
+@FFTW_SYMBOL_PREFIX@tensor_compress
+@FFTW_SYMBOL_PREFIX@tensor_compress_contiguous
+@FFTW_SYMBOL_PREFIX@tensor_copy
+@FFTW_SYMBOL_PREFIX@tensor_copy_except
+@FFTW_SYMBOL_PREFIX@tensor_copy_inplace
+@FFTW_SYMBOL_PREFIX@tensor_copy_sub
+@FFTW_SYMBOL_PREFIX@tensor_destroy
+@FFTW_SYMBOL_PREFIX@tensor_destroy2
+@FFTW_SYMBOL_PREFIX@tensor_destroy4
+@FFTW_SYMBOL_PREFIX@tensor_equal
+@FFTW_SYMBOL_PREFIX@tensor_inplace_locations
+@FFTW_SYMBOL_PREFIX@tensor_inplace_strides
+@FFTW_SYMBOL_PREFIX@tensor_inplace_strides2
+@FFTW_SYMBOL_PREFIX@tensor_kosherp
+@FFTW_SYMBOL_PREFIX@tensor_max_index
+@FFTW_SYMBOL_PREFIX@tensor_md5
+@FFTW_SYMBOL_PREFIX@tensor_min_istride
+@FFTW_SYMBOL_PREFIX@tensor_min_ostride
+@FFTW_SYMBOL_PREFIX@tensor_min_stride
+@FFTW_SYMBOL_PREFIX@tensor_print
+@FFTW_SYMBOL_PREFIX@tensor_split
+@FFTW_SYMBOL_PREFIX@tensor_strides_decrease
+@FFTW_SYMBOL_PREFIX@tensor_sz
+@FFTW_SYMBOL_PREFIX@tensor_tornk1
+@FFTW_SYMBOL_PREFIX@the_planner
+@FFTW_SYMBOL_PREFIX@threads_cleanup
+@FFTW_SYMBOL_PREFIX@threads_conf_standard
+@FFTW_SYMBOL_PREFIX@tile2d
+@FFTW_SYMBOL_PREFIX@toobig
+@FFTW_SYMBOL_PREFIX@transpose
+@FFTW_SYMBOL_PREFIX@transpose_tiled
+@FFTW_SYMBOL_PREFIX@transpose_tiledbuf
+@FFTW_SYMBOL_PREFIX@triggen_destroy
+@FFTW_SYMBOL_PREFIX@twiddle_awake
+@FFTW_SYMBOL_PREFIX@twiddle_length
+;sfftw_cleanup_
+;sfftw_cleanup__
+;sfftw_cleanup_threads_
+;sfftw_cleanup_threads__
+;sfftw_destroy_plan_
+;sfftw_destroy_plan__
+;sfftw_execute_
+;sfftw_execute__
+;sfftw_execute_dft_
+;sfftw_execute_dft__
+;sfftw_execute_dft_c2r_
+;sfftw_execute_dft_c2r__
+;sfftw_execute_dft_r2c_
+;sfftw_execute_dft_r2c__
+;sfftw_execute_r2r_
+;sfftw_execute_r2r__
+;sfftw_execute_split_dft_
+;sfftw_execute_split_dft__
+;sfftw_execute_split_dft_c2r_
+;sfftw_execute_split_dft_c2r__
+;sfftw_execute_split_dft_r2c_
+;sfftw_execute_split_dft_r2c__
+;sfftw_export_wisdom_
+;sfftw_export_wisdom__
+;sfftw_flops_
+;sfftw_flops__
+;sfftw_forget_wisdom_
+;sfftw_forget_wisdom__
+;sfftw_import_system_wisdom_
+;sfftw_import_system_wisdom__
+;sfftw_import_wisdom_
+;sfftw_import_wisdom__
+;sfftw_init_threads_
+;sfftw_init_threads__
+;sfftw_plan_dft_
+;sfftw_plan_dft_1d_
+;sfftw_plan_dft_1d__
+;sfftw_plan_dft_2d_
+;sfftw_plan_dft_2d__
+;sfftw_plan_dft_3d_
+;sfftw_plan_dft_3d__
+;sfftw_plan_dft__
+;sfftw_plan_dft_c2r_
+;sfftw_plan_dft_c2r_1d_
+;sfftw_plan_dft_c2r_1d__
+;sfftw_plan_dft_c2r_2d_
+;sfftw_plan_dft_c2r_2d__
+;sfftw_plan_dft_c2r_3d_
+;sfftw_plan_dft_c2r_3d__
+;sfftw_plan_dft_c2r__
+;sfftw_plan_dft_r2c_
+;sfftw_plan_dft_r2c_1d_
+;sfftw_plan_dft_r2c_1d__
+;sfftw_plan_dft_r2c_2d_
+;sfftw_plan_dft_r2c_2d__
+;sfftw_plan_dft_r2c_3d_
+;sfftw_plan_dft_r2c_3d__
+;sfftw_plan_dft_r2c__
+;sfftw_plan_guru_dft_
+;sfftw_plan_guru_dft__
+;sfftw_plan_guru_dft_c2r_
+;sfftw_plan_guru_dft_c2r__
+;sfftw_plan_guru_dft_r2c_
+;sfftw_plan_guru_dft_r2c__
+;sfftw_plan_guru_r2r_
+;sfftw_plan_guru_r2r__
+;sfftw_plan_guru_split_dft_
+;sfftw_plan_guru_split_dft__
+;sfftw_plan_guru_split_dft_c2r_
+;sfftw_plan_guru_split_dft_c2r__
+;sfftw_plan_guru_split_dft_r2c_
+;sfftw_plan_guru_split_dft_r2c__
+;sfftw_plan_many_dft_
+;sfftw_plan_many_dft__
+;sfftw_plan_many_dft_c2r_
+;sfftw_plan_many_dft_c2r__
+;sfftw_plan_many_dft_r2c_
+;sfftw_plan_many_dft_r2c__
+;sfftw_plan_many_r2r_
+;sfftw_plan_many_r2r__
+;sfftw_plan_r2r_
+;sfftw_plan_r2r_1d_
+;sfftw_plan_r2r_1d__
+;sfftw_plan_r2r_2d_
+;sfftw_plan_r2r_2d__
+;sfftw_plan_r2r_3d_
+;sfftw_plan_r2r_3d__
+;sfftw_plan_r2r__
+;sfftw_plan_with_nthreads_
+;sfftw_plan_with_nthreads__
+;sfftw_print_plan_
+;sfftw_print_plan__
diff --git a/kernel/CMakeLists.txt b/kernel/CMakeLists.txt
new file mode 100644
index 0000000..1552988
--- /dev/null
+++ b/kernel/CMakeLists.txt
@@ -0,0 +1,17 @@
+# pkgincludedir = $(includedir)/fftw3@PREC_SUFFIX@
+# pkginclude_HEADERS = ifftw.h cycle.h
+
+set(kernel_SRCS align.c alloc.c assert.c awake.c buffered.c
+cpy1d.c cpy2d-pair.c cpy2d.c ct.c debug.c extract-reim.c hash.c iabs.c
+kalloc.c md5-1.c md5.c minmax.c ops.c pickdim.c plan.c planner.c
+primes.c print.c problem.c rader.c scan.c solver.c solvtab.c stride.c
+tensor.c tensor1.c tensor2.c tensor3.c tensor4.c tensor5.c tensor7.c
+tensor8.c tensor9.c tile2d.c timer.c transpose.c trig.c twiddle.c
+)
+
+if(BUILD_ALL_STATIC)
+    add_library(kernel STATIC ${kernel_SRCS})
+else(BUILD_ALL_STATIC)
+    prepend_prefix(kernel_SRCS)
+    set(fftw_SRCS ${fftw_SRCS} ${kernel_SRCS} PARENT_SCOPE)
+endif(BUILD_ALL_STATIC)
diff --git a/libbench2/CMakeLists.txt b/libbench2/CMakeLists.txt
new file mode 100644
index 0000000..a8c06b7
--- /dev/null
+++ b/libbench2/CMakeLists.txt
@@ -0,0 +1,11 @@
+set(bench2_SRCS after-ccopy-from.c after-ccopy-to.c
+after-hccopy-from.c after-hccopy-to.c after-rcopy-from.c
+after-rcopy-to.c aligned-main.c allocate.c aset.c
+bench-cost-postprocess.c bench-exit.c bench-main.c can-do.c caset.c
+dotens2.c info.c main.c mflops.c mp.c ovtpvt.c pow2.c problem.c
+report.c speed.c tensor.c timer.c useropt.c util.c verify-dft.c
+verify-lib.c verify-r2r.c verify-rdft2.c verify.c zero.c
+my-getopt.c
+)
+
+add_library(bench2 STATIC ${bench2_SRCS})
diff --git a/rdft/CMakeLists.txt b/rdft/CMakeLists.txt
new file mode 100644
index 0000000..4a9f057
--- /dev/null
+++ b/rdft/CMakeLists.txt
@@ -0,0 +1,23 @@
+add_subdirectory(scalar)
+add_subdirectory(simd)
+
+
+set(RDFT2_SRCS buffered2.c direct2.c nop2.c rank0-rdft2.c rank-geq2-rdft2.c
+plan2.c problem2.c solve2.c vrank-geq1-rdft2.c rdft2-rdft.c
+rdft2-tensor-max-index.c rdft2-inplace-strides.c rdft2-strides.c
+khc2c.c ct-hc2c.c ct-hc2c-direct.c
+)
+
+set(rdft_SRCS hc2hc.c dft-r2hc.c dht-r2hc.c dht-rader.c
+buffered.c conf.c direct-r2r.c direct-r2c.c generic.c
+hc2hc-direct.c hc2hc-generic.c khc2hc.c kr2c.c kr2r.c indirect.c nop.c
+plan.c problem.c rank0.c rank-geq2.c rdft-dht.c solve.c
+vrank-geq1.c vrank3-transpose.c ${RDFT2_SRCS}
+)
+
+if(BUILD_ALL_STATIC)
+    add_library(rdft STATIC ${rdft_SRCS})
+else(BUILD_ALL_STATIC)
+    prepend_prefix(rdft_SRCS)
+    set(fftw_SRCS ${fftw_SRCS} ${rdft_SRCS} ${_fftw_SRCS} PARENT_SCOPE)
+endif(BUILD_ALL_STATIC)
diff --git a/rdft/scalar/CMakeLists.txt b/rdft/scalar/CMakeLists.txt
new file mode 100644
index 0000000..ea61666
--- /dev/null
+++ b/rdft/scalar/CMakeLists.txt
@@ -0,0 +1,12 @@
+add_subdirectory(r2cb)
+add_subdirectory(r2cf)
+add_subdirectory(r2r)
+
+set(rdft_scalar_SRCS ${rdft_scalar_SRCS} hfb.c r2c.c r2r.c hc2c.c)
+
+if(BUILD_ALL_STATIC)
+    add_library(rdft_scalar STATIC ${rdft_scalar_SRCS})
+else(BUILD_ALL_STATIC)
+    prepend_prefix(rdft_scalar_SRCS)
+    set(_fftw_SRCS ${_fftw_SRCS} ${rdft_scalar_SRCS} ${__fftw_SRCS} PARENT_SCOPE)
+endif(BUILD_ALL_STATIC)
diff --git a/rdft/scalar/r2cb/CMakeLists.txt b/rdft/scalar/r2cb/CMakeLists.txt
new file mode 100644
index 0000000..09ac2e8
--- /dev/null
+++ b/rdft/scalar/r2cb/CMakeLists.txt
@@ -0,0 +1,126 @@
+# This Makefile.am specifies a set of codelets, efficient transforms
+# of small sizes, that are used as building blocks (kernels) by FFTW
+# to build up large transforms, as well as the options for generating
+# and compiling them.
+
+# You can customize FFTW for special needs, e.g. to handle certain
+# sizes more efficiently, by adding new codelets to the lists of those
+# included by default.  If you change the list of codelets, any new
+# ones you added will be automatically generated when you run the
+# bootstrap script (see "Generating your own code" in the FFTW
+# manual).
+
+###########################################################################
+# r2cb_<n> is a hard-coded complex-to-real FFT of size <n> (base cases
+# of real-output FFT recursion)
+set(R2CB r2cb_2.c r2cb_3.c r2cb_4.c r2cb_5.c r2cb_6.c r2cb_7.c r2cb_8.c
+r2cb_9.c r2cb_10.c r2cb_11.c r2cb_12.c r2cb_13.c r2cb_14.c r2cb_15.c
+r2cb_16.c r2cb_32.c r2cb_64.c r2cb_128.c r2cb_20.c r2cb_25.c
+# r2cb_30.c r2cb_40.c r2cb_50.c
+)
+
+###########################################################################
+# hb_<r> is a "twiddle" FFT of size <r>, implementing a radix-r DIF
+# step for a real-output FFT.  Every hb codelet must have a
+# corresponding r2cbIII codelet (see below)!
+set(HB hb_2.c hb_3.c hb_4.c hb_5.c hb_6.c hb_7.c hb_8.c hb_9.c
+hb_10.c hb_12.c hb_15.c hb_16.c hb_32.c hb_64.c
+hb_20.c hb_25.c # hb_30.c hb_40.c hb_50.c
+)
+
+# like hb, but generates part of its trig table on the fly (good for large n)
+set(HB2 hb2_4.c hb2_8.c hb2_16.c hb2_32.c
+hb2_5.c hb2_20.c hb2_25.c
+)
+
+# an r2cb transform where the output is shifted by half a sample (input
+# is multiplied by a phase).  This is needed as part of the DIF recursion;
+# every hb_<r> or hb2_<r> codelet should have a corresponding r2cbIII_<r>
+set(R2CBIII r2cbIII_2.c r2cbIII_3.c r2cbIII_4.c r2cbIII_5.c r2cbIII_6.c
+r2cbIII_7.c r2cbIII_8.c r2cbIII_9.c r2cbIII_10.c r2cbIII_12.c
+r2cbIII_15.c r2cbIII_16.c r2cbIII_32.c r2cbIII_64.c
+r2cbIII_20.c r2cbIII_25.c # r2cbIII_30.c r2cbIII_40.c r2cbIII_50.c
+)
+
+###########################################################################
+# hc2cb_<r> is a "twiddle" FFT of size <r>, implementing a radix-r DIF
+# step for a real-input FFT with rdft2-style output.  <r> must be even.
+set(HC2CB hc2cb_2.c hc2cb_4.c hc2cb_6.c hc2cb_8.c hc2cb_10.c hc2cb_12.c
+hc2cb_16.c hc2cb_32.c
+hc2cb_20.c # hc2cb_30.c
+)
+
+set(HC2CBDFT hc2cbdft_2.c hc2cbdft_4.c hc2cbdft_6.c hc2cbdft_8.c
+hc2cbdft_10.c hc2cbdft_12.c hc2cbdft_16.c hc2cbdft_32.c
+hc2cbdft_20.c # hc2cbdft_30.c
+)
+
+# like hc2cb, but generates part of its trig table on the fly (good
+# for large n)
+set(HC2CB2 hc2cb2_4.c hc2cb2_8.c hc2cb2_16.c hc2cb2_32.c
+hc2cb2_20.c # hc2cb2_30.c
+)
+set(HC2CBDFT2 hc2cbdft2_4.c hc2cbdft2_8.c hc2cbdft2_16.c hc2cbdft2_32.c
+hc2cbdft2_20.c # hc2cbdft2_30.c
+)
+
+###########################################################################
+set(ALL_CODELETS ${R2CB} ${HB} ${HB2} ${R2CBIII} ${HC2CB} ${HC2CB2} ${HC2CBDFT} ${HC2CBDFT2})
+
+include(${CMAKE_SOURCE_DIR}/support/codelets.cmake)
+
+set(SOLVTAB_NAME "X(solvtab_rdft_r2cb)")
+
+set(CODLIST ${CMAKE_CURRENT_BINARY_DIR}/codlist.c)
+set(CODELET_NAME codelet_)
+
+write_codelet_list(${CODLIST} ${CODELET_NAME} ${SOLVTAB_NAME} ${ALL_CODELETS})
+
+set(rdft_scalar_r2cb_SRCS ${ALL_CODELETS})
+
+if(BUILD_ALL_STATIC)
+    add_library(rdft_scalar_r2cb STATIC ${rdft_scalar_r2cb_SRCS})
+else(BUILD_ALL_STATIC)
+    prepend_prefix(rdft_scalar_r2cb_SRCS)
+    set(__fftw_SRCS ${__fftw_SRCS} ${rdft_scalar_r2cb_SRCS} ${CODLIST} PARENT_SCOPE)
+endif(BUILD_ALL_STATIC)
+
+# this is old source code which can be changed later
+# only delete codlist.c in maintainer-mode, since it is included in the dist
+# FIXME: is there a way to delete in 'make clean' only when builddir != srcdir?
+#maintainer-clean-local:
+#	rm -f $(CODLIST)
+
+#if MAINTAINER_MODE
+#FLAGS_R2CB=$(RDFT_FLAGS_COMMON) -sign 1
+#FLAGS_HB=$(RDFT_FLAGS_COMMON) -sign 1
+#FLAGS_HB2=$(RDFT_FLAGS_COMMON) -sign 1 -twiddle-log3 -precompute-twiddles
+#FLAGS_HC2CB=$(RDFT_FLAGS_COMMON) -sign 1
+#FLAGS_HC2CB2=$(RDFT_FLAGS_COMMON) -sign 1 -twiddle-log3 -precompute-twiddles
+#FLAGS_R2CBIII=$(RDFT_FLAGS_COMMON) -sign 1
+#
+#r2cb_%.c:  $(CODELET_DEPS) $(GEN_R2CB)
+#	($(PRELUDE_COMMANDS_RDFT); $(TWOVERS) $(GEN_R2CB) $(FLAGS_R2CB) -n $* -name r2cb_$* -include "r2cb.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#hb_%.c:  $(CODELET_DEPS) $(GEN_HC2HC)
+#	($(PRELUDE_COMMANDS_RDFT); $(TWOVERS) $(GEN_HC2HC) $(FLAGS_HB) -n $* -dif -name hb_$* -include "hb.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#hb2_%.c:  $(CODELET_DEPS) $(GEN_HC2HC)
+#	($(PRELUDE_COMMANDS_RDFT); $(TWOVERS) $(GEN_HC2HC) $(FLAGS_HB2) -n $* -dif -name hb2_$* -include "hb.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#r2cbIII_%.c:  $(CODELET_DEPS) $(GEN_R2CB)
+#	($(PRELUDE_COMMANDS_RDFT); $(TWOVERS) $(GEN_R2CB) $(FLAGS_R2CB) -n $* -name r2cbIII_$* -dft-III -include "r2cbIII.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#hc2cb_%.c:  $(CODELET_DEPS) $(GEN_HC2C)
+#	($(PRELUDE_COMMANDS_RDFT); $(TWOVERS) $(GEN_HC2C) $(FLAGS_HC2CB) -n $* -dif -name hc2cb_$* -include "hc2cb.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#hc2cb2_%.c:  $(CODELET_DEPS) $(GEN_HC2C)
+#	($(PRELUDE_COMMANDS_RDFT); $(TWOVERS) $(GEN_HC2C) $(FLAGS_HC2CB2) -n $* -dif -name hc2cb2_$* -include "hc2cb.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#hc2cbdft_%.c:  $(CODELET_DEPS) $(GEN_HC2CDFT)
+#	($(PRELUDE_COMMANDS_RDFT); $(TWOVERS) $(GEN_HC2CDFT) $(FLAGS_HC2CB) -n $* -dif -name hc2cbdft_$* -include "hc2cb.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#hc2cbdft2_%.c:  $(CODELET_DEPS) $(GEN_HC2CDFT)
+#	($(PRELUDE_COMMANDS_RDFT); $(TWOVERS) $(GEN_HC2CDFT) $(FLAGS_HC2CB) -n $* -dif -name hc2cbdft2_$* -include "hc2cb.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#endif # MAINTAINER_MODE
diff --git a/rdft/scalar/r2cf/CMakeLists.txt b/rdft/scalar/r2cf/CMakeLists.txt
new file mode 100644
index 0000000..7ffb3ee
--- /dev/null
+++ b/rdft/scalar/r2cf/CMakeLists.txt
@@ -0,0 +1,128 @@
+# This Makefile.am specifies a set of codelets, efficient transforms
+# of small sizes, that are used as building blocks (kernels) by FFTW
+# to build up large transforms, as well as the options for generating
+# and compiling them.
+
+# You can customize FFTW for special needs, e.g. to handle certain
+# sizes more efficiently, by adding new codelets to the lists of those
+# included by default.  If you change the list of codelets, any new
+# ones you added will be automatically generated when you run the
+# bootstrap script (see "Generating your own code" in the FFTW
+# manual).
+
+###########################################################################
+
+###########################################################################
+# r2cf_<n> is a hard-coded real-to-complex FFT of size <n> (base cases
+# of real-input FFT recursion)
+set(R2CF r2cf_2.c r2cf_3.c r2cf_4.c r2cf_5.c r2cf_6.c r2cf_7.c r2cf_8.c
+r2cf_9.c r2cf_10.c r2cf_11.c r2cf_12.c r2cf_13.c r2cf_14.c r2cf_15.c
+r2cf_16.c r2cf_32.c r2cf_64.c r2cf_128.c
+r2cf_20.c r2cf_25.c # r2cf_30.c r2cf_40.c r2cf_50.c
+)
+
+###########################################################################
+# hf_<r> is a "twiddle" FFT of size <r>, implementing a radix-r DIT
+# step for a real-input FFT.  Every hf codelet must have a
+# corresponding r2cfII codelet (see below)!
+set(HF hf_2.c hf_3.c hf_4.c hf_5.c hf_6.c hf_7.c hf_8.c hf_9.c
+hf_10.c hf_12.c hf_15.c hf_16.c hf_32.c hf_64.c
+hf_20.c hf_25.c # hf_30.c hf_40.c hf_50.c
+)
+
+# like hf, but generates part of its trig table on the fly (good for large n)
+set(HF2 hf2_4.c hf2_8.c hf2_16.c hf2_32.c
+hf2_5.c hf2_20.c hf2_25.c
+)
+
+# an r2cf transform where the input is shifted by half a sample (output
+# is multiplied by a phase).  This is needed as part of the DIT recursion;
+# every hf_<r> or hf2_<r> codelet should have a corresponding r2cfII_<r>
+set(R2CFII r2cfII_2.c r2cfII_3.c r2cfII_4.c r2cfII_5.c r2cfII_6.c	
+r2cfII_7.c r2cfII_8.c r2cfII_9.c r2cfII_10.c r2cfII_12.c r2cfII_15.c
+r2cfII_16.c r2cfII_32.c r2cfII_64.c
+r2cfII_20.c r2cfII_25.c # r2cfII_30.c r2cfII_40.c r2cfII_50.c
+)
+
+###########################################################################
+# hc2cf_<r> is a "twiddle" FFT of size <r>, implementing a radix-r DIT
+# step for a real-input FFT with rdft2-style output.  <r> must be even.
+set(HC2CF hc2cf_2.c hc2cf_4.c hc2cf_6.c hc2cf_8.c hc2cf_10.c hc2cf_12.c
+hc2cf_16.c hc2cf_32.c
+hc2cf_20.c # hc2cf_30.c
+)
+
+set(HC2CFDFT hc2cfdft_2.c hc2cfdft_4.c hc2cfdft_6.c hc2cfdft_8.c
+hc2cfdft_10.c hc2cfdft_12.c hc2cfdft_16.c hc2cfdft_32.c
+hc2cfdft_20.c # hc2cfdft_30.c
+)
+
+# like hc2cf, but generates part of its trig table on the fly (good
+# for large n)
+set(HC2CF2 hc2cf2_4.c hc2cf2_8.c hc2cf2_16.c hc2cf2_32.c
+hc2cf2_20.c # hc2cf2_30.c
+)
+set(HC2CFDFT2 hc2cfdft2_4.c hc2cfdft2_8.c hc2cfdft2_16.c hc2cfdft2_32.c
+hc2cfdft2_20.c # hc2cfdft2_30.c
+)
+
+###########################################################################
+set(ALL_CODELETS ${R2CF} ${HF} ${HF2} ${R2CFII} ${HC2CF} ${HC2CF2} ${HC2CFDFT} ${HC2CFDFT2})
+
+include(${CMAKE_SOURCE_DIR}/support/codelets.cmake)
+
+set(SOLVTAB_NAME "X(solvtab_rdft_r2cf)")
+
+set(CODLIST ${CMAKE_CURRENT_BINARY_DIR}/codlist.c)
+set(CODELET_NAME codelet_)
+
+write_codelet_list(${CODLIST} ${CODELET_NAME} ${SOLVTAB_NAME} ${ALL_CODELETS})
+
+set(rdft_scalar_r2cf_SRCS ${ALL_CODELETS})
+
+if(BUILD_ALL_STATIC)
+    add_library(rdft_scalar_r2cf STATIC ${rdft_scalar_r2cf_SRCS})
+else(BUILD_ALL_STATIC)
+    prepend_prefix(rdft_scalar_r2cf_SRCS)
+    set(__fftw_SRCS ${__fftw_SRCS} ${rdft_scalar_r2cf_SRCS} ${CODLIST} PARENT_SCOPE)
+endif(BUILD_ALL_STATIC)
+
+# this is old source code which can be changed later
+# only delete codlist.c in maintainer-mode, since it is included in the dist
+# FIXME: is there a way to delete in 'make clean' only when builddir != srcdir?
+#maintainer-clean-local:
+#	rm -f $(CODLIST)
+
+#if MAINTAINER_MODE
+#FLAGS_R2CF=$(RDFT_FLAGS_COMMON)
+#FLAGS_HF=$(RDFT_FLAGS_COMMON)
+#FLAGS_HF2=$(RDFT_FLAGS_COMMON) -twiddle-log3 -precompute-twiddles
+#FLAGS_HC2CF=$(RDFT_FLAGS_COMMON)
+#FLAGS_HC2CF2=$(RDFT_FLAGS_COMMON) -twiddle-log3 -precompute-twiddles
+#FLAGS_R2CFII=$(RDFT_FLAGS_COMMON)
+#
+#r2cf_%.c:  $(CODELET_DEPS) $(GEN_R2CF)
+#	($(PRELUDE_COMMANDS_RDFT); $(TWOVERS) $(GEN_R2CF) $(FLAGS_R2CF) -n $* -name r2cf_$* -include "r2cf.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#hf_%.c:  $(CODELET_DEPS) $(GEN_HC2HC)
+#	($(PRELUDE_COMMANDS_RDFT); $(TWOVERS) $(GEN_HC2HC) $(FLAGS_HF) -n $* -dit -name hf_$* -include "hf.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#hf2_%.c:  $(CODELET_DEPS) $(GEN_HC2HC)
+#	($(PRELUDE_COMMANDS_RDFT); $(TWOVERS) $(GEN_HC2HC) $(FLAGS_HF2) -n $* -dit -name hf2_$* -include "hf.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#r2cfII_%.c:  $(CODELET_DEPS) $(GEN_R2CF)
+#	($(PRELUDE_COMMANDS_RDFT); $(TWOVERS) $(GEN_R2CF) $(FLAGS_R2CF) -n $* -name r2cfII_$* -dft-II -include "r2cfII.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#hc2cf_%.c:  $(CODELET_DEPS) $(GEN_HC2C)
+#	($(PRELUDE_COMMANDS_RDFT); $(TWOVERS) $(GEN_HC2C) $(FLAGS_HC2CF) -n $* -dit -name hc2cf_$* -include "hc2cf.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#hc2cf2_%.c:  $(CODELET_DEPS) $(GEN_HC2C)
+#	($(PRELUDE_COMMANDS_RDFT); $(TWOVERS) $(GEN_HC2C) $(FLAGS_HC2CF2) -n $* -dit -name hc2cf2_$* -include "hc2cf.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#hc2cfdft_%.c:  $(CODELET_DEPS) $(GEN_HC2CDFT)
+#	($(PRELUDE_COMMANDS_RDFT); $(TWOVERS) $(GEN_HC2CDFT) $(FLAGS_HC2CF) -n $* -dit -name hc2cfdft_$* -include "hc2cf.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#hc2cfdft2_%.c:  $(CODELET_DEPS) $(GEN_HC2CDFT)
+#	($(PRELUDE_COMMANDS_RDFT); $(TWOVERS) $(GEN_HC2CDFT) $(FLAGS_HC2CF2) -n $* -dit -name hc2cfdft2_$* -include "hc2cf.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#endif # MAINTAINER_MODE
diff --git a/rdft/scalar/r2r/CMakeLists.txt b/rdft/scalar/r2r/CMakeLists.txt
new file mode 100644
index 0000000..1a95451
--- /dev/null
+++ b/rdft/scalar/r2r/CMakeLists.txt
@@ -0,0 +1,100 @@
+# This Makefile.am specifies a set of codelets, efficient transforms
+# of small sizes, that are used as building blocks (kernels) by FFTW
+# to build up large transforms, as well as the options for generating
+# and compiling them.
+
+# You can customize FFTW for special needs, e.g. to handle certain
+# sizes more efficiently, by adding new codelets to the lists of those
+# included by default.  If you change the list of codelets, any new
+# ones you added will be automatically generated when you run the
+# bootstrap script (see "Generating your own code" in the FFTW
+# manual).
+
+###########################################################################
+
+###########################################################################
+# The following lines specify the REDFT/RODFT/DHT sizes for which to generate
+# specialized codelets.  Currently, only REDFT01/10 of size 8 (used in JPEG).
+
+# e<a><b>_<n> is a hard-coded REDFT<a><b> FFT (DCT) of size <n>
+set(E00 # e00_2.c e00_3.c e00_4.c e00_5.c e00_6.c e00_7.c e00_8.c
+)
+set(E01 e01_8.c # e01_2.c e01_3.c e01_4.c e01_5.c e01_6.c e01_7.c
+)
+set(E10 e10_8.c # e10_2.c e10_3.c e10_4.c e10_5.c e10_6.c e10_7.c
+)
+set(E11 # e11_2.c e11_3.c e11_4.c e11_5.c e11_6.c e11_7.c e11_8.c
+)
+
+# o<a><b>_<n> is a hard-coded RODFT<a><b> FFT (DST) of size <n>
+set(O00 # o00_2.c o00_3.c o00_4.c o00_5.c o00_6.c o00_7.c o00_8.c
+)
+set(O01 # o01_2.c o01_3.c o01_4.c o01_5.c o01_6.c o01_7.c o01_8.c
+)
+set(O10 # o10_2.c o10_3.c o10_4.c o10_5.c o10_6.c o10_7.c o10_8.c
+)
+set(O11 # o11_2.c o11_3.c o11_4.c o11_5.c o11_6.c o11_7.c o11_8.c
+)
+
+# dht_<n> is a hard-coded DHT of size <n>
+set(DHT # dht_2.c dht_3.c dht_4.c dht_5.c dht_6.c dht_7.c dht_8.c
+)
+
+###########################################################################
+set(ALL_CODELETS ${E00} ${E01} ${E10} ${E11} ${O00} ${O01} ${O10} ${O11} ${DHT})
+
+include(${CMAKE_SOURCE_DIR}/support/codelets.cmake)
+
+set(SOLVTAB_NAME "X(solvtab_rdft_r2r)")
+
+set(CODLIST ${CMAKE_CURRENT_BINARY_DIR}/codlist.c)
+set(CODELET_NAME codelet_)
+
+write_codelet_list(${CODLIST} ${CODELET_NAME} ${SOLVTAB_NAME} ${ALL_CODELETS})
+
+set(rdft_scalar_r2r_SRCS ${ALL_CODELETS})
+
+if(BUILD_ALL_STATIC)
+    add_library(rdft_scalar_r2r STATIC ${rdft_scalar_r2r_SRCS})
+else(BUILD_ALL_STATIC)
+    prepend_prefix(rdft_scalar_r2r_SRCS)
+    set(__fftw_SRCS ${__fftw_SRCS} ${rdft_scalar_r2r_SRCS} ${CODLIST} PARENT_SCOPE)
+endif(BUILD_ALL_STATIC)
+
+# this is old source code which can be changed later
+# only delete codlist.c in maintainer-mode, since it is included in the dist
+# FIXME: is there a way to delete in 'make clean' only when builddir != srcdir?
+#maintainer-clean-local:
+#	rm -f $(CODLIST)
+
+#if MAINTAINER_MODE
+#FLAGS_N1=$(DFT_FLAGS_COMMON)
+#FLAGS_T1=$(DFT_FLAGS_COMMON)
+#FLAGS_T2=$(DFT_FLAGS_COMMON) -twiddle-log3 -precompute-twiddles
+#FLAGS_F1=$(DFT_FLAGS_COMMON)
+#FLAGS_F2=$(DFT_FLAGS_COMMON) -twiddle-log3  -precompute-twiddles
+#FLAGS_Q1=$(DFT_FLAGS_COMMON) -reload-twiddle
+#FLAGS_Q2=$(DFT_FLAGS_COMMON) -twiddle-log3  -precompute-twiddles
+#
+#n1_%.c:  $(CODELET_DEPS) $(GEN_NOTW)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_NOTW) $(FLAGS_N1) -n $* -name n1_$* -include "n.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#t1_%.c:  $(CODELET_DEPS) $(GEN_TWIDDLE)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_TWIDDLE) $(FLAGS_T1) -n $* -name t1_$* -include "t.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#t2_%.c:  $(CODELET_DEPS) $(GEN_TWIDDLE)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_TWIDDLE) $(FLAGS_T2) -n $* -name t2_$* -include "t.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#f1_%.c:  $(CODELET_DEPS) $(GEN_TWIDDLE)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_TWIDDLE) $(FLAGS_F1) -dif -n $* -name f1_$* -include "f.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#f2_%.c:  $(CODELET_DEPS) $(GEN_TWIDDLE)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_TWIDDLE) $(FLAGS_F2) -dif -n $* -name f2_$* -include "f.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#q1_%.c:  $(CODELET_DEPS) $(GEN_TWIDSQ)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_TWIDSQ) $(FLAGS_Q1) -dif -n $* -name q1_$* -include "q.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#q2_%.c:  $(CODELET_DEPS) $(GEN_TWIDSQ)
+#	($(PRELUDE_COMMANDS_DFT); $(TWOVERS) $(GEN_TWIDSQ) $(FLAGS_Q2) -dif -n $* -name q2_$* -include "q.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#endif # MAINTAINER_MODE
diff --git a/rdft/simd/CMakeLists.txt b/rdft/simd/CMakeLists.txt
new file mode 100644
index 0000000..09191cb
--- /dev/null
+++ b/rdft/simd/CMakeLists.txt
@@ -0,0 +1,10 @@
+add_subdirectory(codelets)
+
+set(rdft_simd_SRCS hc2cbv.c hc2cfv.c)
+
+if(BUILD_ALL_STATIC)
+    add_library(rdft_simd STATIC ${rdft_simd_SRCS})
+else(BUILD_ALL_STATIC)
+    prepend_prefix(rdft_simd_SRCS)
+    set(_fftw_SRCS ${_fftw_SRCS} ${rdft_simd_SRCS} ${__fftw_SRCS} PARENT_SCOPE)
+endif(BUILD_ALL_STATIC)
diff --git a/rdft/simd/codelets/CMakeLists.txt b/rdft/simd/codelets/CMakeLists.txt
new file mode 100644
index 0000000..1b4bc06
--- /dev/null
+++ b/rdft/simd/codelets/CMakeLists.txt
@@ -0,0 +1,61 @@
+# This Makefile.am specifies a set of codelets, efficient transforms
+# of small sizes, that are used as building blocks (kernels) by FFTW
+# to build up large transforms, as well as the options for generating
+# and compiling them.
+
+# You can customize FFTW for special needs, e.g. to handle certain
+# sizes more efficiently, by adding new codelets to the lists of those
+# included by default.  If you change the list of codelets, any new
+# ones you added will be automatically generated when you run the
+# bootstrap script (see "Generating your own code" in the FFTW
+# manual).
+
+###########################################################################
+
+set(HC2CFDFTV hc2cfdftv_2.c hc2cfdftv_4.c hc2cfdftv_6.c hc2cfdftv_8.c
+hc2cfdftv_10.c hc2cfdftv_12.c hc2cfdftv_16.c hc2cfdftv_32.c
+hc2cfdftv_20.c # hc2cfdftv_30.c
+)
+
+set(HC2CBDFTV hc2cbdftv_2.c hc2cbdftv_4.c hc2cbdftv_6.c hc2cbdftv_8.c
+hc2cbdftv_10.c hc2cbdftv_12.c hc2cbdftv_16.c hc2cbdftv_32.c
+hc2cbdftv_20.c # hc2cbdftv_30.c
+)
+
+###########################################################################
+set(SIMD_CODELETS ${HC2CFDFTV} ${HC2CBDFTV})
+
+if(HAVE_SIMD)
+    set(ALL_CODELETS ${SIMD_CODELETS})
+else(HAVE_SIMD)
+    set(ALL_CODELETS)
+endif(HAVE_SIMD)
+
+set(SOLVTAB_NAME "X(solvtab_rdft_simd)")
+set(CODLIST ${CMAKE_CURRENT_BINARY_DIR}/codlist.c)
+set(CODELET_NAME codelet_)
+
+set(rdft_simd_codelets_SRCS ${ALL_CODELETS})
+
+# special rules for regenerating codelets.
+include(${CMAKE_SOURCE_DIR}/support/codelets.cmake)
+
+write_codelet_list(${CODLIST} ${CODELET_NAME} ${SOLVTAB_NAME} ${ALL_CODELETS})
+
+if(BUILD_ALL_STATIC)
+    add_library(rdft_simd_codelets STATIC ${ALL_CODELETS})
+else(BUILD_ALL_STATIC)
+    prepend_prefix(rdft_simd_codelets_SRCS)
+    set(__fftw_SRCS ${__fftw_SRCS} ${rdft_simd_codelets_SRCS} ${CODLIST} PARENT_SCOPE)
+endif(BUILD_ALL_STATIC)
+
+#if MAINTAINER_MODE
+#FLAGS_HC2C=-simd $(FLAGS_COMMON) -pipeline-latency 8 -trivial-stores -variables 32 -no-generate-bytw
+#
+#hc2cfdftv_%.c:  $(CODELET_DEPS) $(GEN_HC2CDFT_C)
+#	($(PRELUDE_COMMANDS_RDFT); $(TWOVERS) $(GEN_HC2CDFT_C) $(FLAGS_HC2C) -n $* -dit -name hc2cfdftv_$* -include "hc2cfv.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#hc2cbdftv_%.c:  $(CODELET_DEPS) $(GEN_HC2CDFT_C)
+#	($(PRELUDE_COMMANDS_RDFT); $(TWOVERS) $(GEN_HC2CDFT_C) $(FLAGS_HC2C) -n $* -dif -sign 1 -name hc2cbdftv_$* -include "hc2cbv.h") | $(ADD_DATE) | $(INDENT) >$@
+#
+#endif # MAINTAINER_MODE
diff --git a/reodft/CMakeLists.txt b/reodft/CMakeLists.txt
new file mode 100644
index 0000000..51d382b
--- /dev/null
+++ b/reodft/CMakeLists.txt
@@ -0,0 +1,12 @@
+set(reodft_SRCS conf.c reodft010e-r2hc.c
+reodft11e-radix2.c reodft11e-r2hc-odd.c redft00e-r2hc-pad.c
+rodft00e-r2hc-pad.c reodft00e-splitradix.c
+# redft00e-r2hc.c rodft00e-r2hc.c reodft11e-r2hc.c
+)
+
+if(BUILD_ALL_STATIC)
+    add_library(reodft STATIC ${reodft_SRCS})
+else(BUILD_ALL_STATIC)
+    prepend_prefix(reodft_SRCS)
+    set(fftw_SRCS ${fftw_SRCS} ${reodft_SRCS} ${_fftw_SRCS} PARENT_SCOPE)
+endif(BUILD_ALL_STATIC)
diff --git a/simd/CMakeLists.txt b/simd/CMakeLists.txt
new file mode 100644
index 0000000..713be75
--- /dev/null
+++ b/simd/CMakeLists.txt
@@ -0,0 +1,10 @@
+set(simd_SRCS altivec.c sse.c sse2.c taint.c mips_ps.c)
+
+add_subdirectory(nonportable)
+
+if(BUILD_ALL_STATIC)
+    add_library(simd STATIC ${simd_SRCS})
+else(BUILD_ALL_STATIC)
+    prepend_prefix(simd_SRCS)
+    set(fftw_SRCS ${fftw_SRCS} ${simd_SRCS} ${_fftw_SRCS} PARENT_SCOPE)
+endif(BUILD_ALL_STATIC)
diff --git a/simd/nonportable/CMakeLists.txt b/simd/nonportable/CMakeLists.txt
new file mode 100644
index 0000000..44b6e0b
--- /dev/null
+++ b/simd/nonportable/CMakeLists.txt
@@ -0,0 +1,8 @@
+set(simd_nonportable_SRCS  sse.c sse2.c)
+
+if(BUILD_ALL_STATIC)
+    add_library(simd_nonportable STATIC ${simd_nonportable_SRCS})
+else(BUILD_ALL_STATIC)
+    prepend_prefix(simd_nonportable_SRCS)
+    set(_fftw_SRCS ${_fftw_SRCS} ${simd_nonportable_SRCS} PARENT_SCOPE)
+endif(BUILD_ALL_STATIC)
diff --git a/simd/simd-sse.h b/simd/simd-sse.h
index 290ed7b..ed70027 100644
--- a/simd/simd-sse.h
+++ b/simd/simd-sse.h
@@ -1,315 +1,315 @@
-/*
- * Copyright (c) 2003, 2007-8 Matteo Frigo
- * Copyright (c) 2003, 2007-8 Massachusetts Institute of Technology
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-
-#ifndef FFTW_SINGLE
-#error "SSE only works in single precision"
-#endif
-
-#define VL 2            /* SIMD complex vector length */
-#define ALIGNMENT 8     /* alignment for LD/ST */
-#define ALIGNMENTA 16   /* alignment for LDA/STA */
-#define SIMD_VSTRIDE_OKA(x) ((x) == 2)
-#define SIMD_STRIDE_OKPAIR SIMD_STRIDE_OK
-
-#define RIGHT_CPU X(have_sse)
-extern int RIGHT_CPU(void);
-
-/* gcc compiles the following code only when __SSE__ is defined */
-#if defined(__SSE__) || !defined(__GNUC__)
-
-/* some versions of glibc's sys/cdefs.h define __inline to be empty,
-   which is wrong because xmmintrin.h defines several inline
-   procedures */
-#undef __inline
-
-#include <xmmintrin.h>
-
-typedef __m128 V;
-#define VADD _mm_add_ps
-#define VSUB _mm_sub_ps
-#define VMUL _mm_mul_ps
-#define VXOR _mm_xor_ps
-#define SHUFPS _mm_shuffle_ps
-#define STOREH(addr, val) _mm_storeh_pi((__m64 *)(addr), val)
-#define STOREL(addr, val) _mm_storel_pi((__m64 *)(addr), val)
-#define UNPCKH _mm_unpackhi_ps
-#define UNPCKL _mm_unpacklo_ps
-
-#ifdef __GNUC__
-#  define DVK(var, val) const V var = __extension__ ({		\
-     static const union fvec _var = { {val, val, val, val} };	\
-     _var.v;							\
-   })
-#  define LDK(x) x
-
-  /* we use inline asm because gcc generates slow code for
-     _mm_loadh_pi().  gcc insists upon having an existing variable for
-     VAL, which is however never used.  Thus, it generates code to move
-     values in and out the variable.  Worse still, gcc-4.0 stores VAL on
-     the stack, causing valgrind to complain about uninitialized reads.
-  */   
-
-  static inline V LD(const R *x, INT ivs, const R *aligned_like)
-  {
-       V var;
-       (void)aligned_like; /* UNUSED */
-       __asm__("movlps %1, %0\n\tmovhps %2, %0"
-	       : "=x"(var) : "m"(x[0]), "m"(x[ivs]));
-       return var;
-  }
-
-#else
-
-# define DVK(var, val) const R var = K(val)
-# define LDK(x) _mm_set_ps1(x)
-# define LOADH(addr, val) _mm_loadh_pi(val, (const __m64 *)(addr))
-# define LOADL0(addr, val) _mm_loadl_pi(val, (const __m64 *)(addr))
-
-  static inline V LD(const R *x, INT ivs, const R *aligned_like)
-  {
-       V var;
-       (void)aligned_like; /* UNUSED */
-       var = LOADL0(x, var);
-       var = LOADH(x + ivs, var);
-       return var;
-  }
-
-#endif
-
-union fvec {
-     R f[4];
-     V v;
-};
-
-union uvec {
-     unsigned u[4];
-     V v;
-};
-
-#define VFMA(a, b, c) VADD(c, VMUL(a, b))
-#define VFNMS(a, b, c) VSUB(c, VMUL(a, b))
-#define VFMS(a, b, c) VSUB(VMUL(a, b), c)
-
-#define SHUFVAL(fp0,fp1,fp2,fp3) \
-   (((fp3) << 6) | ((fp2) << 4) | ((fp1) << 2) | ((fp0)))
-
-
-static inline V LDA(const R *x, INT ivs, const R *aligned_like)
-{
-     (void)aligned_like; /* UNUSED */
-     (void)ivs; /* UNUSED */
-     return *(const V *)x;
-}
-
-static inline void ST(R *x, V v, INT ovs, const R *aligned_like)
-{
-     (void)aligned_like; /* UNUSED */
-     /* WARNING: the extra_iter hack depends upon STOREL occurring
-	after STOREH */
-     STOREH(x + ovs, v);
-     STOREL(x, v);
-}
-
-static inline void STA(R *x, V v, INT ovs, const R *aligned_like)
-{
-     (void)aligned_like; /* UNUSED */
-     (void)ovs; /* UNUSED */
-     *(V *)x = v;
-}
-
-#if 0
-/* this should be faster but it isn't. */
-static inline void STN2(R *x, V v0, V v1, INT ovs)
-{
-     STA(x, SHUFPS(v0, v1, SHUFVAL(0, 1, 0, 1)), ovs, 0);
-     STA(x + ovs, SHUFPS(v0, v1, SHUFVAL(2, 3, 2, 3)), ovs, 0);
-}
-#endif
-#define STM2 ST
-#define STN2(x, v0, v1, ovs) /* nop */
-
-#define STM4(x, v, ovs, aligned_like) /* no-op */
-
-#ifdef VISUAL_CXX_DOES_NOT_SUCK
-static inline void STN4(R *x, V v0, V v1, V v2, V v3, INT ovs)
-{
-     V x0, x1, x2, x3;
-     x0 = UNPCKL(v0, v2);
-     x1 = UNPCKH(v0, v2);
-     x2 = UNPCKL(v1, v3);
-     x3 = UNPCKH(v1, v3);
-     STA(x, UNPCKL(x0, x2), 0, 0);
-     STA(x + ovs, UNPCKH(x0, x2), 0, 0);
-     STA(x + 2 * ovs, UNPCKL(x1, x3), 0, 0);
-     STA(x + 3 * ovs, UNPCKH(x1, x3), 0, 0);
-}
-#else /* Visual C++ sucks */
-
-/*
-  Straight from the mouth of the horse:
-
-     We "reserved" the possibility of aligning arguments with 
-     __declspec(align(X)) passed by value by issuing this error. 
-
-     The first 3 parameters of type __m64 (or other MMX types) are
-     passed in registers.  The rest would be passed on the stack.  We
-     decided aligning the stack was wasteful, especially for __m128
-     parameters.  Also, we thought it would be infrequent that people
-     would want to pass more than 3 by value.
-
-     If we didn't issue an error, we would have to binary compatibility
-     in the future if we decided to align the arguments.
-
-
-     Hope that explains it. 
-     -- 
-     Jason Shirk, Visual C++ Compiler Team 
-     This posting is provided AS IS with no warranties, and confers no rights
-*/
-
-#define STN4(x, v0, v1, v2, v3, ovs)			\
-{							\
-     V xxx0, xxx1, xxx2, xxx3;				\
-     xxx0 = UNPCKL(v0, v2);				\
-     xxx1 = UNPCKH(v0, v2);				\
-     xxx2 = UNPCKL(v1, v3);				\
-     xxx3 = UNPCKH(v1, v3);				\
-     STA(x, UNPCKL(xxx0, xxx2), 0, 0);			\
-     STA(x + ovs, UNPCKH(xxx0, xxx2), 0, 0);		\
-     STA(x + 2 * ovs, UNPCKL(xxx1, xxx3), 0, 0);	\
-     STA(x + 3 * ovs, UNPCKH(xxx1, xxx3), 0, 0);	\
-}
-#endif
-
-static inline V FLIP_RI(V x)
-{
-     return SHUFPS(x, x, SHUFVAL(1, 0, 3, 2));
-}
-
-extern const union uvec X(sse_pmpm);
-static inline V VCONJ(V x)
-{
-     return VXOR(X(sse_pmpm).v, x);
-}
-
-static inline V VBYI(V x)
-{
-     return FLIP_RI(VCONJ(x));
-}
-
-static inline V VZMUL(V tx, V sr)
-{
-     V tr = SHUFPS(tx, tx, SHUFVAL(0, 0, 2, 2));
-     V ti = SHUFPS(tx, tx, SHUFVAL(1, 1, 3, 3));
-     tr = VMUL(tr, sr);
-     sr = VBYI(sr);
-     return VADD(tr, VMUL(ti, sr));
-}
-
-static inline V VZMULJ(V tx, V sr)
-{
-     V tr = SHUFPS(tx, tx, SHUFVAL(0, 0, 2, 2));
-     V ti = SHUFPS(tx, tx, SHUFVAL(1, 1, 3, 3));
-     tr = VMUL(tr, sr);
-     sr = VBYI(sr);
-     return VSUB(tr, VMUL(ti, sr));
-}
-
-static inline V VZMULI(V tx, V sr)
-{
-     V tr = SHUFPS(tx, tx, SHUFVAL(0, 0, 2, 2));
-     V ti = SHUFPS(tx, tx, SHUFVAL(1, 1, 3, 3));
-     ti = VMUL(ti, sr);
-     sr = VBYI(sr);
-     return VSUB(VMUL(tr, sr), ti);
-}
-
-static inline V VZMULIJ(V tx, V sr)
-{
-     V tr = SHUFPS(tx, tx, SHUFVAL(0, 0, 2, 2));
-     V ti = SHUFPS(tx, tx, SHUFVAL(1, 1, 3, 3));
-     ti = VMUL(ti, sr);
-     sr = VBYI(sr);
-     return VADD(VMUL(tr, sr), ti);
-}
-
-#define VFMAI(b, c) VADD(c, VBYI(b))
-#define VFNMSI(b, c) VSUB(c, VBYI(b))
-
-/* twiddle storage #1: compact, slower */
-#define VTW1(v,x)  \
-  {TW_COS, v, x}, {TW_COS, v+1, x}, {TW_SIN, v, x}, {TW_SIN, v+1, x}
-#define TWVL1 (VL)
-
-static inline V BYTW1(const R *t, V sr)
-{
-     const V *twp = (const V *)t;
-     V tx = twp[0];
-     V tr = UNPCKL(tx, tx);
-     V ti = UNPCKH(tx, tx);
-     tr = VMUL(tr, sr);
-     sr = VBYI(sr);
-     return VADD(tr, VMUL(ti, sr));
-}
-
-static inline V BYTWJ1(const R *t, V sr)
-{
-     const V *twp = (const V *)t;
-     V tx = twp[0];
-     V tr = UNPCKL(tx, tx);
-     V ti = UNPCKH(tx, tx);
-     tr = VMUL(tr, sr);
-     sr = VBYI(sr);
-     return VSUB(tr, VMUL(ti, sr));
-}
-
-/* twiddle storage #2: twice the space, faster (when in cache) */
-#define VTW2(v,x)							\
-  {TW_COS, v, x}, {TW_COS, v, x}, {TW_COS, v+1, x}, {TW_COS, v+1, x},	\
-  {TW_SIN, v, -x}, {TW_SIN, v, x}, {TW_SIN, v+1, -x}, {TW_SIN, v+1, x}
-#define TWVL2 (2 * VL)
-
-static inline V BYTW2(const R *t, V sr)
-{
-     const V *twp = (const V *)t;
-     V si = FLIP_RI(sr);
-     V tr = twp[0], ti = twp[1];
-     return VADD(VMUL(tr, sr), VMUL(ti, si));
-}
-
-static inline V BYTWJ2(const R *t, V sr)
-{
-     const V *twp = (const V *)t;
-     V si = FLIP_RI(sr);
-     V tr = twp[0], ti = twp[1];
-     return VSUB(VMUL(tr, sr), VMUL(ti, si));
-}
-
-/* twiddle storage #3 */
-#define VTW3(v,x) {TW_CEXP, v, x}, {TW_CEXP, v+1, x}
-#define TWVL3 (VL)
-
-/* twiddle storage for split arrays */
-#define VTWS(v,x)							\
-  {TW_COS, v, x}, {TW_COS, v+1, x}, {TW_COS, v+2, x}, {TW_COS, v+3, x},	\
-  {TW_SIN, v, x}, {TW_SIN, v+1, x}, {TW_SIN, v+2, x}, {TW_SIN, v+3, x}	
-#define TWVLS (2 * VL)
-
-#endif /* __SSE__ */
+/*
+ * Copyright (c) 2003, 2007-8 Matteo Frigo
+ * Copyright (c) 2003, 2007-8 Massachusetts Institute of Technology
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef FFTW_SINGLE
+#error "SSE only works in single precision"
+#endif
+
+#define VL 2            /* SIMD complex vector length */
+#define ALIGNMENT 8     /* alignment for LD/ST */
+#define ALIGNMENTA 16   /* alignment for LDA/STA */
+#define SIMD_VSTRIDE_OKA(x) ((x) == 2)
+#define SIMD_STRIDE_OKPAIR SIMD_STRIDE_OK
+
+#define RIGHT_CPU X(have_sse)
+extern int RIGHT_CPU(void);
+
+/* gcc compiles the following code only when __SSE__ is defined */
+#if defined(__SSE__) || !defined(__GNUC__)
+
+/* some versions of glibc's sys/cdefs.h define __inline to be empty,
+   which is wrong because xmmintrin.h defines several inline
+   procedures */
+#undef __inline
+
+#include <xmmintrin.h>
+
+typedef __m128 V;
+#define VADD _mm_add_ps
+#define VSUB _mm_sub_ps
+#define VMUL _mm_mul_ps
+#define VXOR _mm_xor_ps
+#define SHUFPS _mm_shuffle_ps
+#define STOREH(addr, val) _mm_storeh_pi((__m64 *)(addr), val)
+#define STOREL(addr, val) _mm_storel_pi((__m64 *)(addr), val)
+#define UNPCKH _mm_unpackhi_ps
+#define UNPCKL _mm_unpacklo_ps
+
+#ifdef __GNUC__
+#  define DVK(var, val) const V var = __extension__ ({		\
+     static const union fvec _var = { {val, val, val, val} };	\
+     _var.v;							\
+   })
+#  define LDK(x) x
+
+  /* we use inline asm because gcc generates slow code for
+     _mm_loadh_pi().  gcc insists upon having an existing variable for
+     VAL, which is however never used.  Thus, it generates code to move
+     values in and out the variable.  Worse still, gcc-4.0 stores VAL on
+     the stack, causing valgrind to complain about uninitialized reads.
+  */   
+
+  static inline V LD(const R *x, INT ivs, const R *aligned_like)
+  {
+       V var;
+       (void)aligned_like; /* UNUSED */
+       __asm__("movlps %1, %0\n\tmovhps %2, %0"
+	       : "=x"(var) : "m"(x[0]), "m"(x[ivs]));
+       return var;
+  }
+
+#else
+
+# define DVK(var, val) const R var = K(val)
+# define LDK(x) _mm_set_ps1(x)
+# define LOADH(addr, val) _mm_loadh_pi(val, (const __m64 *)(addr))
+# define LOADL0(addr, val) _mm_loadl_pi(val, (const __m64 *)(addr))
+
+  static V LD(const R *x, INT ivs, const R *aligned_like)
+  {
+       V var;
+       (void)aligned_like; /* UNUSED */
+       var = LOADL0(x, var);
+       var = LOADH(x + ivs, var);
+       return var;
+  }
+
+#endif
+
+union fvec {
+     R f[4];
+     V v;
+};
+
+union uvec {
+     unsigned u[4];
+     V v;
+};
+
+#define VFMA(a, b, c) VADD(c, VMUL(a, b))
+#define VFNMS(a, b, c) VSUB(c, VMUL(a, b))
+#define VFMS(a, b, c) VSUB(VMUL(a, b), c)
+
+#define SHUFVAL(fp0,fp1,fp2,fp3) \
+   (((fp3) << 6) | ((fp2) << 4) | ((fp1) << 2) | ((fp0)))
+
+
+static V LDA(const R *x, INT ivs, const R *aligned_like)
+{
+     (void)aligned_like; /* UNUSED */
+     (void)ivs; /* UNUSED */
+     return *(const V *)x;
+}
+
+static void ST(R *x, V v, INT ovs, const R *aligned_like)
+{
+     (void)aligned_like; /* UNUSED */
+     /* WARNING: the extra_iter hack depends upon STOREL occurring
+	after STOREH */
+     STOREH(x + ovs, v);
+     STOREL(x, v);
+}
+
+static void STA(R *x, V v, INT ovs, const R *aligned_like)
+{
+     (void)aligned_like; /* UNUSED */
+     (void)ovs; /* UNUSED */
+     *(V *)x = v;
+}
+
+#if 0
+/* this should be faster but it isn't. */
+static void STN2(R *x, V v0, V v1, INT ovs)
+{
+     STA(x, SHUFPS(v0, v1, SHUFVAL(0, 1, 0, 1)), ovs, 0);
+     STA(x + ovs, SHUFPS(v0, v1, SHUFVAL(2, 3, 2, 3)), ovs, 0);
+}
+#endif
+#define STM2 ST
+#define STN2(x, v0, v1, ovs) /* nop */
+
+#define STM4(x, v, ovs, aligned_like) /* no-op */
+
+#ifdef VISUAL_CXX_DOES_NOT_SUCK
+static void STN4(R *x, V v0, V v1, V v2, V v3, INT ovs)
+{
+     V x0, x1, x2, x3;
+     x0 = UNPCKL(v0, v2);
+     x1 = UNPCKH(v0, v2);
+     x2 = UNPCKL(v1, v3);
+     x3 = UNPCKH(v1, v3);
+     STA(x, UNPCKL(x0, x2), 0, 0);
+     STA(x + ovs, UNPCKH(x0, x2), 0, 0);
+     STA(x + 2 * ovs, UNPCKL(x1, x3), 0, 0);
+     STA(x + 3 * ovs, UNPCKH(x1, x3), 0, 0);
+}
+#else /* Visual C++ sucks */
+
+/*
+  Straight from the mouth of the horse:
+
+     We "reserved" the possibility of aligning arguments with 
+     __declspec(align(X)) passed by value by issuing this error. 
+
+     The first 3 parameters of type __m64 (or other MMX types) are
+     passed in registers.  The rest would be passed on the stack.  We
+     decided aligning the stack was wasteful, especially for __m128
+     parameters.  Also, we thought it would be infrequent that people
+     would want to pass more than 3 by value.
+
+     If we didn't issue an error, we would have to binary compatibility
+     in the future if we decided to align the arguments.
+
+
+     Hope that explains it. 
+     -- 
+     Jason Shirk, Visual C++ Compiler Team 
+     This posting is provided AS IS with no warranties, and confers no rights
+*/
+
+#define STN4(x, v0, v1, v2, v3, ovs)			\
+{							\
+     V xxx0, xxx1, xxx2, xxx3;				\
+     xxx0 = UNPCKL(v0, v2);				\
+     xxx1 = UNPCKH(v0, v2);				\
+     xxx2 = UNPCKL(v1, v3);				\
+     xxx3 = UNPCKH(v1, v3);				\
+     STA(x, UNPCKL(xxx0, xxx2), 0, 0);			\
+     STA(x + ovs, UNPCKH(xxx0, xxx2), 0, 0);		\
+     STA(x + 2 * ovs, UNPCKL(xxx1, xxx3), 0, 0);	\
+     STA(x + 3 * ovs, UNPCKH(xxx1, xxx3), 0, 0);	\
+}
+#endif
+
+static V FLIP_RI(V x)
+{
+     return SHUFPS(x, x, SHUFVAL(1, 0, 3, 2));
+}
+
+extern const union uvec X(sse_pmpm);
+static V VCONJ(V x)
+{
+     return VXOR(X(sse_pmpm).v, x);
+}
+
+static V VBYI(V x)
+{
+     return FLIP_RI(VCONJ(x));
+}
+
+static V VZMUL(V tx, V sr)
+{
+     V tr = SHUFPS(tx, tx, SHUFVAL(0, 0, 2, 2));
+     V ti = SHUFPS(tx, tx, SHUFVAL(1, 1, 3, 3));
+     tr = VMUL(tr, sr);
+     sr = VBYI(sr);
+     return VADD(tr, VMUL(ti, sr));
+}
+
+static V VZMULJ(V tx, V sr)
+{
+     V tr = SHUFPS(tx, tx, SHUFVAL(0, 0, 2, 2));
+     V ti = SHUFPS(tx, tx, SHUFVAL(1, 1, 3, 3));
+     tr = VMUL(tr, sr);
+     sr = VBYI(sr);
+     return VSUB(tr, VMUL(ti, sr));
+}
+
+static V VZMULI(V tx, V sr)
+{
+     V tr = SHUFPS(tx, tx, SHUFVAL(0, 0, 2, 2));
+     V ti = SHUFPS(tx, tx, SHUFVAL(1, 1, 3, 3));
+     ti = VMUL(ti, sr);
+     sr = VBYI(sr);
+     return VSUB(VMUL(tr, sr), ti);
+}
+
+static V VZMULIJ(V tx, V sr)
+{
+     V tr = SHUFPS(tx, tx, SHUFVAL(0, 0, 2, 2));
+     V ti = SHUFPS(tx, tx, SHUFVAL(1, 1, 3, 3));
+     ti = VMUL(ti, sr);
+     sr = VBYI(sr);
+     return VADD(VMUL(tr, sr), ti);
+}
+
+#define VFMAI(b, c) VADD(c, VBYI(b))
+#define VFNMSI(b, c) VSUB(c, VBYI(b))
+
+/* twiddle storage #1: compact, slower */
+#define VTW1(v,x)  \
+  {TW_COS, v, x}, {TW_COS, v+1, x}, {TW_SIN, v, x}, {TW_SIN, v+1, x}
+#define TWVL1 (VL)
+
+static V BYTW1(const R *t, V sr)
+{
+     const V *twp = (const V *)t;
+     V tx = twp[0];
+     V tr = UNPCKL(tx, tx);
+     V ti = UNPCKH(tx, tx);
+     tr = VMUL(tr, sr);
+     sr = VBYI(sr);
+     return VADD(tr, VMUL(ti, sr));
+}
+
+static V BYTWJ1(const R *t, V sr)
+{
+     const V *twp = (const V *)t;
+     V tx = twp[0];
+     V tr = UNPCKL(tx, tx);
+     V ti = UNPCKH(tx, tx);
+     tr = VMUL(tr, sr);
+     sr = VBYI(sr);
+     return VSUB(tr, VMUL(ti, sr));
+}
+
+/* twiddle storage #2: twice the space, faster (when in cache) */
+#define VTW2(v,x)							\
+  {TW_COS, v, x}, {TW_COS, v, x}, {TW_COS, v+1, x}, {TW_COS, v+1, x},	\
+  {TW_SIN, v, -x}, {TW_SIN, v, x}, {TW_SIN, v+1, -x}, {TW_SIN, v+1, x}
+#define TWVL2 (2 * VL)
+
+static V BYTW2(const R *t, V sr)
+{
+     const V *twp = (const V *)t;
+     V si = FLIP_RI(sr);
+     V tr = twp[0], ti = twp[1];
+     return VADD(VMUL(tr, sr), VMUL(ti, si));
+}
+
+static V BYTWJ2(const R *t, V sr)
+{
+     const V *twp = (const V *)t;
+     V si = FLIP_RI(sr);
+     V tr = twp[0], ti = twp[1];
+     return VSUB(VMUL(tr, sr), VMUL(ti, si));
+}
+
+/* twiddle storage #3 */
+#define VTW3(v,x) {TW_CEXP, v, x}, {TW_CEXP, v+1, x}
+#define TWVL3 (VL)
+
+/* twiddle storage for split arrays */
+#define VTWS(v,x)							\
+  {TW_COS, v, x}, {TW_COS, v+1, x}, {TW_COS, v+2, x}, {TW_COS, v+3, x},	\
+  {TW_SIN, v, x}, {TW_SIN, v+1, x}, {TW_SIN, v+2, x}, {TW_SIN, v+3, x}	
+#define TWVLS (2 * VL)
+
+#endif /* __SSE__ */
diff --git a/simd/simd-sse.h.bak b/simd/simd-sse.h.bak
new file mode 100644
index 0000000..99ef9da
--- /dev/null
+++ b/simd/simd-sse.h.bak
@@ -0,0 +1,319 @@
+/*
+ * Copyright (c) 2003, 2007-8 Matteo Frigo
+ * Copyright (c) 2003, 2007-8 Massachusetts Institute of Technology
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef FFTW_SINGLE
+#error "SSE only works in single precision"
+#endif
+
+#define VL 2            /* SIMD complex vector length */
+#define ALIGNMENT 8     /* alignment for LD/ST */
+#define ALIGNMENTA 16   /* alignment for LDA/STA */
+#define SIMD_VSTRIDE_OKA(x) ((x) == 2)
+#define SIMD_STRIDE_OKPAIR SIMD_STRIDE_OK
+
+#define RIGHT_CPU X(have_sse)
+extern int RIGHT_CPU(void);
+
+/* gcc compiles the following code only when __SSE__ is defined */
+#if defined(__SSE__) || !defined(__GNUC__)
+
+/* some versions of glibc's sys/cdefs.h define __inline to be empty,
+   which is wrong because xmmintrin.h defines several inline
+   procedures */
+#undef __inline
+
+#include <xmmintrin.h>
+
+typedef __m128 V;
+#define VADD _mm_add_ps
+#define VSUB _mm_sub_ps
+#define VMUL _mm_mul_ps
+#define VXOR _mm_xor_ps
+#define SHUFPS _mm_shuffle_ps
+#define STOREH(addr, val) _mm_storeh_pi((__m64 *)(addr), val)
+#define STOREL(addr, val) _mm_storel_pi((__m64 *)(addr), val)
+#define UNPCKH _mm_unpackhi_ps
+#define UNPCKL _mm_unpacklo_ps
+
+#ifdef __GNUC__
+#  define DVK(var, val) const V var = __extension__ ({		\
+     static const union fvec _var = { {val, val, val, val} };	\
+     _var.v;							\
+   })
+#  define LDK(x) x
+
+  /* we use inline asm because gcc generates slow code for
+     _mm_loadh_pi().  gcc insists upon having an existing variable for
+     VAL, which is however never used.  Thus, it generates code to move
+     values in and out the variable.  Worse still, gcc-4.0 stores VAL on
+     the stack, causing valgrind to complain about uninitialized reads.
+  */   
+
+  static inline V LD(const R *x, INT ivs, const R *aligned_like)
+  {
+       V var;
+       (void)aligned_like; /* UNUSED */
+       __asm__("movlps %1, %0\n\tmovhps %2, %0"
+	       : "=x"(var) : "m"(x[0]), "m"(x[ivs]));
+       return var;
+  }
+
+#else
+
+# define DVK(var, val) const R var = K(val)
+# define LDK(x) _mm_set_ps1(x)
+# define LOADH(addr, val) _mm_loadh_pi(val, (const __m64 *)(addr))
+# define LOADL0(addr, val) _mm_loadl_pi(val, (const __m64 *)(addr))
+
+#ifndef __INTEL_COMPILER
+  static inline V LD(const R *x, INT ivs, const R *aligned_like)
+#else
+  static V LD(const R *x, INT ivs, const R *aligned_like)
+#endif
+  {
+       V var;
+       (void)aligned_like; /* UNUSED */
+       var = LOADL0(x, var);
+       var = LOADH(x + ivs, var);
+       return var;
+  }
+
+#endif
+
+union fvec {
+     R f[4];
+     V v;
+};
+
+union uvec {
+     unsigned u[4];
+     V v;
+};
+
+#define VFMA(a, b, c) VADD(c, VMUL(a, b))
+#define VFNMS(a, b, c) VSUB(c, VMUL(a, b))
+#define VFMS(a, b, c) VSUB(VMUL(a, b), c)
+
+#define SHUFVAL(fp0,fp1,fp2,fp3) \
+   (((fp3) << 6) | ((fp2) << 4) | ((fp1) << 2) | ((fp0)))
+
+
+static inline V LDA(const R *x, INT ivs, const R *aligned_like)
+{
+     (void)aligned_like; /* UNUSED */
+     (void)ivs; /* UNUSED */
+     return *(const V *)x;
+}
+
+static inline void ST(R *x, V v, INT ovs, const R *aligned_like)
+{
+     (void)aligned_like; /* UNUSED */
+     /* WARNING: the extra_iter hack depends upon STOREL occurring
+	after STOREH */
+     STOREH(x + ovs, v);
+     STOREL(x, v);
+}
+
+static inline void STA(R *x, V v, INT ovs, const R *aligned_like)
+{
+     (void)aligned_like; /* UNUSED */
+     (void)ovs; /* UNUSED */
+     *(V *)x = v;
+}
+
+#if 0
+/* this should be faster but it isn't. */
+static inline void STN2(R *x, V v0, V v1, INT ovs)
+{
+     STA(x, SHUFPS(v0, v1, SHUFVAL(0, 1, 0, 1)), ovs, 0);
+     STA(x + ovs, SHUFPS(v0, v1, SHUFVAL(2, 3, 2, 3)), ovs, 0);
+}
+#endif
+#define STM2 ST
+#define STN2(x, v0, v1, ovs) /* nop */
+
+#define STM4(x, v, ovs, aligned_like) /* no-op */
+
+#ifdef VISUAL_CXX_DOES_NOT_SUCK
+static inline void STN4(R *x, V v0, V v1, V v2, V v3, INT ovs)
+{
+     V x0, x1, x2, x3;
+     x0 = UNPCKL(v0, v2);
+     x1 = UNPCKH(v0, v2);
+     x2 = UNPCKL(v1, v3);
+     x3 = UNPCKH(v1, v3);
+     STA(x, UNPCKL(x0, x2), 0, 0);
+     STA(x + ovs, UNPCKH(x0, x2), 0, 0);
+     STA(x + 2 * ovs, UNPCKL(x1, x3), 0, 0);
+     STA(x + 3 * ovs, UNPCKH(x1, x3), 0, 0);
+}
+#else /* Visual C++ sucks */
+
+/*
+  Straight from the mouth of the horse:
+
+     We "reserved" the possibility of aligning arguments with 
+     __declspec(align(X)) passed by value by issuing this error. 
+
+     The first 3 parameters of type __m64 (or other MMX types) are
+     passed in registers.  The rest would be passed on the stack.  We
+     decided aligning the stack was wasteful, especially for __m128
+     parameters.  Also, we thought it would be infrequent that people
+     would want to pass more than 3 by value.
+
+     If we didn't issue an error, we would have to binary compatibility
+     in the future if we decided to align the arguments.
+
+
+     Hope that explains it. 
+     -- 
+     Jason Shirk, Visual C++ Compiler Team 
+     This posting is provided AS IS with no warranties, and confers no rights
+*/
+
+#define STN4(x, v0, v1, v2, v3, ovs)			\
+{							\
+     V xxx0, xxx1, xxx2, xxx3;				\
+     xxx0 = UNPCKL(v0, v2);				\
+     xxx1 = UNPCKH(v0, v2);				\
+     xxx2 = UNPCKL(v1, v3);				\
+     xxx3 = UNPCKH(v1, v3);				\
+     STA(x, UNPCKL(xxx0, xxx2), 0, 0);			\
+     STA(x + ovs, UNPCKH(xxx0, xxx2), 0, 0);		\
+     STA(x + 2 * ovs, UNPCKL(xxx1, xxx3), 0, 0);	\
+     STA(x + 3 * ovs, UNPCKH(xxx1, xxx3), 0, 0);	\
+}
+#endif
+
+static inline V FLIP_RI(V x)
+{
+     return SHUFPS(x, x, SHUFVAL(1, 0, 3, 2));
+}
+
+extern const union uvec X(sse_pmpm);
+static inline V VCONJ(V x)
+{
+     return VXOR(X(sse_pmpm).v, x);
+}
+
+static inline V VBYI(V x)
+{
+     return FLIP_RI(VCONJ(x));
+}
+
+static inline V VZMUL(V tx, V sr)
+{
+     V tr = SHUFPS(tx, tx, SHUFVAL(0, 0, 2, 2));
+     V ti = SHUFPS(tx, tx, SHUFVAL(1, 1, 3, 3));
+     tr = VMUL(tr, sr);
+     sr = VBYI(sr);
+     return VADD(tr, VMUL(ti, sr));
+}
+
+static inline V VZMULJ(V tx, V sr)
+{
+     V tr = SHUFPS(tx, tx, SHUFVAL(0, 0, 2, 2));
+     V ti = SHUFPS(tx, tx, SHUFVAL(1, 1, 3, 3));
+     tr = VMUL(tr, sr);
+     sr = VBYI(sr);
+     return VSUB(tr, VMUL(ti, sr));
+}
+
+static inline V VZMULI(V tx, V sr)
+{
+     V tr = SHUFPS(tx, tx, SHUFVAL(0, 0, 2, 2));
+     V ti = SHUFPS(tx, tx, SHUFVAL(1, 1, 3, 3));
+     ti = VMUL(ti, sr);
+     sr = VBYI(sr);
+     return VSUB(VMUL(tr, sr), ti);
+}
+
+static inline V VZMULIJ(V tx, V sr)
+{
+     V tr = SHUFPS(tx, tx, SHUFVAL(0, 0, 2, 2));
+     V ti = SHUFPS(tx, tx, SHUFVAL(1, 1, 3, 3));
+     ti = VMUL(ti, sr);
+     sr = VBYI(sr);
+     return VADD(VMUL(tr, sr), ti);
+}
+
+#define VFMAI(b, c) VADD(c, VBYI(b))
+#define VFNMSI(b, c) VSUB(c, VBYI(b))
+
+/* twiddle storage #1: compact, slower */
+#define VTW1(v,x)  \
+  {TW_COS, v, x}, {TW_COS, v+1, x}, {TW_SIN, v, x}, {TW_SIN, v+1, x}
+#define TWVL1 (VL)
+
+static inline V BYTW1(const R *t, V sr)
+{
+     const V *twp = (const V *)t;
+     V tx = twp[0];
+     V tr = UNPCKL(tx, tx);
+     V ti = UNPCKH(tx, tx);
+     tr = VMUL(tr, sr);
+     sr = VBYI(sr);
+     return VADD(tr, VMUL(ti, sr));
+}
+
+static inline V BYTWJ1(const R *t, V sr)
+{
+     const V *twp = (const V *)t;
+     V tx = twp[0];
+     V tr = UNPCKL(tx, tx);
+     V ti = UNPCKH(tx, tx);
+     tr = VMUL(tr, sr);
+     sr = VBYI(sr);
+     return VSUB(tr, VMUL(ti, sr));
+}
+
+/* twiddle storage #2: twice the space, faster (when in cache) */
+#define VTW2(v,x)							\
+  {TW_COS, v, x}, {TW_COS, v, x}, {TW_COS, v+1, x}, {TW_COS, v+1, x},	\
+  {TW_SIN, v, -x}, {TW_SIN, v, x}, {TW_SIN, v+1, -x}, {TW_SIN, v+1, x}
+#define TWVL2 (2 * VL)
+
+static inline V BYTW2(const R *t, V sr)
+{
+     const V *twp = (const V *)t;
+     V si = FLIP_RI(sr);
+     V tr = twp[0], ti = twp[1];
+     return VADD(VMUL(tr, sr), VMUL(ti, si));
+}
+
+static inline V BYTWJ2(const R *t, V sr)
+{
+     const V *twp = (const V *)t;
+     V si = FLIP_RI(sr);
+     V tr = twp[0], ti = twp[1];
+     return VSUB(VMUL(tr, sr), VMUL(ti, si));
+}
+
+/* twiddle storage #3 */
+#define VTW3(v,x) {TW_CEXP, v, x}, {TW_CEXP, v+1, x}
+#define TWVL3 (VL)
+
+/* twiddle storage for split arrays */
+#define VTWS(v,x)							\
+  {TW_COS, v, x}, {TW_COS, v+1, x}, {TW_COS, v+2, x}, {TW_COS, v+3, x},	\
+  {TW_SIN, v, x}, {TW_SIN, v+1, x}, {TW_SIN, v+2, x}, {TW_SIN, v+3, x}	
+#define TWVLS (2 * VL)
+
+#endif /* __SSE__ */
diff --git a/support/codelets.cmake b/support/codelets.cmake
new file mode 100644
index 0000000..5161407
--- /dev/null
+++ b/support/codelets.cmake
@@ -0,0 +1,18 @@
+# generate file codlist.c
+
+macro(write_codelet_list CODLIST CODELET_NAME SOLVTAB_NAME)
+    file(RELATIVE_PATH filename ${CMAKE_BINARY_DIR} ${CODLIST})
+    message(STATUS "writing codelet list file ${filename}")
+    file(WRITE ${CODLIST} "#include \"ifftw.h\"\n\n")
+    foreach(codelet ${ARGN})
+        string(REGEX REPLACE "([A-Za-z0-9_]*)\\.c" "\\1" codeletbase "${codelet}")
+        file(APPEND ${CODLIST} "extern void X(${CODELET_NAME}${codeletbase})(planner *);\n")
+    endforeach(codelet ${ARGN})
+    file(APPEND ${CODLIST} "\n\nextern const solvtab ${SOLVTAB_NAME};\n")
+    file(APPEND ${CODLIST} "const solvtab ${SOLVTAB_NAME} = {\n")
+    foreach(codelet ${ARGN})
+        string(REGEX REPLACE "([A-Za-z0-9_]*)\\.c" "\\1" codeletbase "${codelet}")
+        file(APPEND ${CODLIST} "    SOLVTAB(X(${CODELET_NAME}${codeletbase})),\n")
+    endforeach(codelet ${ARGN})
+    file(APPEND ${CODLIST} "    SOLVTAB_END\n};\n")
+endmacro(write_codelet_list CODLIST CODELET_NAME SOLVTAB_NAME)
\ No newline at end of file
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
new file mode 100644
index 0000000..c5ef717
--- /dev/null
+++ b/tests/CMakeLists.txt
@@ -0,0 +1,71 @@
+#noinst_PROGRAMS = bench
+#EXTRA_DIST = check.pl README
+
+#if SMP
+#if !COMBINED_THREADS
+#LIBFFTWTHREADS = $(top_builddir)/threads/libfftw3@PREC_SUFFIX@_threads.la
+#endif
+#else
+#LIBFFTWTHREADS = 
+#endif
+
+set(bench_SRCS bench.c hook.c fftw-bench.c)
+add_executable(bench ${bench_SRCS})
+target_link_libraries(bench fftw bench2 fftw)
+
+#check-local: bench$(EXEEXT)
+#	perl -w $(srcdir)/check.pl -r -c=30 -v `pwd`/bench
+#	@echo "--------------------------------------------------------------"
+#	@echo "         FFTW transforms passed basic tests!"
+#	@echo "--------------------------------------------------------------"
+#if SMP
+#	perl -w $(srcdir)/check.pl -r -c=30 -v --nthreads=2 `pwd`/bench
+#	@echo "--------------------------------------------------------------"
+#	@echo "         FFTW threaded transforms passed basic tests!"
+#	@echo "--------------------------------------------------------------"
+#endif
+#
+#bigcheck: bench$(EXEEXT)
+#	perl -w $(srcdir)/check.pl -a -v `pwd`/bench
+#	@echo "--------------------------------------------------------------"
+#	@echo "         FFTW transforms passed big tests!"
+#	@echo "--------------------------------------------------------------"
+#if SMP
+#	perl -w $(srcdir)/check.pl -a -v --nthreads=2 `pwd`/bench
+#	perl -w $(srcdir)/check.pl -a -v --nthreads=3 `pwd`/bench
+#	perl -w $(srcdir)/check.pl -a -v --nthreads=10 `pwd`/bench
+#	@echo "--------------------------------------------------------------"
+#	@echo "         FFTW threaded transforms passed big tests!"
+#	@echo "--------------------------------------------------------------"
+#endif
+#
+#smallcheck: bench$(EXEEXT)
+#	perl -w $(srcdir)/check.pl -r -c=1 -v `pwd`/bench
+#	perl -w $(srcdir)/check.pl -r --estimate -c=5 -v `pwd`/bench
+#	@echo "--------------------------------------------------------------"
+#	@echo "         FFTW transforms passed a few tests!"
+#	@echo "--------------------------------------------------------------"
+#if SMP
+#	perl -w $(srcdir)/check.pl -r --estimate -c=2 -v --nthreads=2 `pwd`/bench
+#	@echo "--------------------------------------------------------------"
+#	@echo "         FFTW threaded transforms passed a few tests!"
+#	@echo "--------------------------------------------------------------"
+#endif
+#
+#paranoid-check: bench$(EXEEXT)
+#if SMP
+#	perl -w $(srcdir)/check.pl -a --patient --nthreads=10 --paranoid `pwd`/bench
+#	perl -w $(srcdir)/check.pl -a --patient --nthreads=7 --paranoid `pwd`/bench
+#	perl -w $(srcdir)/check.pl -a --patient --nthreads=3 --paranoid `pwd`/bench
+#	perl -w $(srcdir)/check.pl -a --patient --nthreads=2 --paranoid `pwd`/bench
+#endif
+#	perl -w $(srcdir)/check.pl -a --patient --paranoid `pwd`/bench
+#
+#exhaustive-check: bench$(EXEEXT)
+#if SMP
+#	perl -w $(srcdir)/check.pl -a --exhaustive --nthreads=10 --paranoid `pwd`/bench
+#	perl -w $(srcdir)/check.pl -a --exhaustive --nthreads=7 --paranoid `pwd`/bench
+#	perl -w $(srcdir)/check.pl -a --exhaustive --nthreads=3 --paranoid `pwd`/bench
+#	perl -w $(srcdir)/check.pl -a --exhaustive --nthreads=2 --paranoid `pwd`/bench
+#endif
+#	perl -w $(srcdir)/check.pl -a --exhaustive --paranoid `pwd`/bench
diff --git a/threads/CMakeLists.txt b/threads/CMakeLists.txt
new file mode 100644
index 0000000..42f9211
--- /dev/null
+++ b/threads/CMakeLists.txt
@@ -0,0 +1,9 @@
+set(threads_SRCS api.c conf.c threads.c openmp.c dft-vrank-geq1.c ct.c rdft-vrank-geq1.c hc2hc.c vrank-geq1-rdft2.c f77api.c
+)
+
+if(BUILD_ALL_STATIC)
+    add_library(threads STATIC ${threads_SRCS})
+else(BUILD_ALL_STATIC)
+    prepend_prefix(threads_SRCS)
+    set(fftw_SRCS ${fftw_SRCS} ${threads_SRCS} PARENT_SCOPE)
+endif(BUILD_ALL_STATIC)
\ No newline at end of file
diff --git a/threads/api.c b/threads/api.c
index 8b17ea9..1042d60 100644
--- a/threads/api.c
+++ b/threads/api.c
@@ -1,81 +1,80 @@
-/*
- * Copyright (c) 2003, 2007-8 Matteo Frigo
- * Copyright (c) 2003, 2007-8 Massachusetts Institute of Technology
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-
-#include "api.h"
-#include "threads.h"
-
-static int threads_inited = 0;
-
-static void threads_register_hooks(void)
-{
-     X(mksolver_ct_hook) = X(mksolver_ct_threads);
-     X(mksolver_hc2hc_hook) = X(mksolver_hc2hc_threads);
-}
-
-static void threads_unregister_hooks(void)
-{
-     X(mksolver_ct_hook) = 0;
-     X(mksolver_hc2hc_hook) = 0;
-}
-
-/* should be called before all other FFTW functions! */
-int X(init_threads)(void)
-{
-     if (!threads_inited) {
-	  planner *plnr;
-
-          if (X(ithreads_init)())
-               return 0;
-
-	  threads_register_hooks();
-
-	  /* this should be the first time the_planner is called,
-	     and hence the time it is configured */
-	  plnr = X(the_planner)();
-	  X(threads_conf_standard)(plnr);
-	       
-          threads_inited = 1;
-     }
-     return 1;
-}
-
-
-void X(cleanup_threads)(void)
-{
-     X(cleanup)();
-     if (threads_inited) {
-	  X(threads_cleanup)();
-	  threads_unregister_hooks();
-	  threads_inited = 0;
-     }
-}
-
-void X(plan_with_nthreads)(int nthreads)
-{
-     planner *plnr;
-
-     if (!threads_inited) {
-	  X(cleanup)();
-	  X(init_threads)();
-     }
-     A(threads_inited);
-     plnr = X(the_planner)();
-     plnr->nthr = X(imax)(1, nthreads);
-}
+/*
+ * Copyright (c) 2003, 2007-8 Matteo Frigo
+ * Copyright (c) 2003, 2007-8 Massachusetts Institute of Technology
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include "api.h"
+#include "threads.h"
+
+static int threads_inited = 0;
+
+static void threads_register_hooks(void)
+{
+     X(mksolver_ct_hook) = X(mksolver_ct_threads);
+     X(mksolver_hc2hc_hook) = X(mksolver_hc2hc_threads);
+}
+
+static void threads_unregister_hooks(void)
+{
+     X(mksolver_ct_hook) = 0;
+     X(mksolver_hc2hc_hook) = 0;
+}
+
+/* should be called before all other FFTW functions! */
+int X(init_threads)(void)
+{
+     if (!threads_inited) {
+	  planner *plnr;
+
+          if (X(ithreads_init)())
+               return 0;
+
+	  threads_register_hooks();
+
+	  /* this should be the first time the_planner is called,
+	     and hence the time it is configured */
+	  plnr = X(the_planner)();
+	  X(threads_conf_standard)(plnr);
+	       
+          threads_inited = 1;
+     }
+     return 1;
+}
+
+void X(cleanup_threads)(void)
+{
+     X(cleanup)();
+     if (threads_inited) {
+	  X(threads_cleanup)();
+	  threads_unregister_hooks();
+	  threads_inited = 0;
+     }
+}
+
+void X(plan_with_nthreads)(int nthreads)
+{
+     planner *plnr;
+
+     if (!threads_inited) {
+	  X(cleanup)();
+	  X(init_threads)();
+     }
+     A(threads_inited);
+     plnr = X(the_planner)();
+     plnr->nthr = X(imax)(1, nthreads);
+}
